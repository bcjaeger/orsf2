---
title: "Introduction to aorsf"
description: >
  Learn how to get started with the basics of aorsf.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to aorsf}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.height = 5, 
  fig.width = 7
)
```

This article covers core features of the `aorsf` package. Separate articles will cover these features in more detail. 

## Background: ORSF

The oblique random survival forest (ORSF) is an extension of the axis-based RSF algorithm. Axis based RSFs can be fit with several R packages, including `RandomForestSRC`, `party`, and `ranger`. However, apart from `aorsf` and `obliqueRSF`, few R packages fit ORSFs.

## What is an oblique decision tree?

Decision trees are developed by splitting a set of training data into two new subsets, with the goal of having more similarity within the new subsets than between them. This splitting process is repeated on the resulting subsets of data until a stopping criterion is met. When the new subsets of data are formed based on a single predictor, the decision tree is said to be axis-based because the splits of the data appear perpendicular to the axis of the predictor. When linear combinations of variables are used instead of a single variable, the tree is oblique because the splits of the data are neither parallel nor at a right angle to the axis. 

```{r fig_oblique_v_axis, out.width='100%', echo = FALSE, fig.cap="Decision trees for classification with axis-based splitting (left) and oblique splitting (right). Cases are orange squares; controls are purple circles. Both trees partition the predictor space defined by variables X1 and X2, but the oblique splits do a better job of separating the two classes."}

knitr::include_graphics('tree_axis_v_oblique.png')

```

## Accelerated ORSF

The purpose of `aorsf` ('a' is short for accelerated) is to provide routines to fit ORSFs that will scale adequately to large data sets. For example, `aorsf::orsf()` runs hundreds of times faster than its predecessor, `obliqueRSF::ORSF()`.

To fit an accelerated ORSF model, use the `orsf` function:

```{r}

library(aorsf)
library(ggplot2)

set.seed(329)

orsf_fit <- orsf(data = pbc_orsf, 
                 formula = Surv(time, status) ~ . - id, 
                 n_tree = 2500)

orsf_fit

```

you may notice that the first input of `aorsf` is `data`. This is a design choice that makes it easier to use `orsf` with pipes (i.e., `%>%` or `|>`). For instance,

```{r, eval=FALSE}
library(dplyr)

orsf_fit <- pbc_orsf |> 
 select(-id) |> 
 orsf(formula = Surv(time, status) ~ .)

```

## Interpretation

`aorsf` includes several functions dedicated to interpretation of ORSFs, both through estimation of partial dependence and variable importance.

### Variable importance

`aorsf` provides multiple ways to compute variable importance. 

- To compute negation importance, ORSF multiplies each coefficient of that variable by -1 and then re-computes the out-of-sample (sometimes referred to as out-of-bag) accuracy of the ORSF model. 

    ```{r}

    orsf_vi_negate(orsf_fit)

    ```

- You can also compute variable importance using permutation, a more classical approach.

    ```{r}
  
    orsf_vi_permute(orsf_fit)
  
    ```

- A faster alternative to permutation and negation importance is ANOVA importance, which computes the proportion of times each variable obtains a low p-value (p < 0.01) while the forest is grown.

    ```{r}
    
    orsf_vi_anova(orsf_fit)
    
    ```



### Partial dependence

Partial dependence shows the expected prediction from an ORSF model for a given set of predictor values.

- `orsf_pd()` shows summary values of predictions for the given set of predictor values

    ```{r}
    
    # make a list containing the variable values you
    # want to compute partial dependence for
    pd_spec <- list(edema = c("0", "0.5", "1"),
                    bili = seq(0.6, 7.1, by = 0.1))
    
    # orsf_pd automatically computes pd for all combinations
    # in the list (this can be turned off with expand_grid = FALSE)
    pd_data <- orsf_pd(object = orsf_fit, 
                               pd_spec = pd_spec,
                               expand_grid = TRUE, 
                               pred_horizon = 365.25 * 5)
    
    ggplot(pd_data) +
     aes(x = bili, y = mean, col = edema) +
     geom_line() + 
     labs(y = 'Predicted risk',
          x = 'Bilirubin',
          title = 'Partial dependence of bilirubin and edema') +
     scale_y_continuous(limits = c(0, 1))
    
    ```

- `orsf_ice()` shows predictions for each observation if the specified predictors are fixed at the specified predictor values. 

    ```{r}
    
    # make a list containing the variable values you
    # want to compute partial dependence for
    pd_spec <- list(edema = c("0", "0.5", "1"),
                    bili = seq(0.6, 7.1, by = 0.1))
    
    # orsf_pd automatically computes pd for all combinations
    # in the list (this can be turned off with expand_grid = FALSE)
    pd_data <- orsf_ice(object = orsf_fit, 
                           pd_spec = pd_spec,
                           expand_grid = TRUE, 
                           pred_horizon = 365.25 * 5)
    
    pd_data$edema = paste("Edema =", pd_data$edema)
    
    ggplot(pd_data) +
     aes(x = bili, y = pred, group = id_row) +
     geom_line(color = 'grey', alpha = 0.25) + 
     geom_smooth(group = 1) +
     labs(y = 'Predicted risk',
          x = 'Bilirubin',
          title = 'Partial dependence of bilirubin and edema') +
     scale_y_continuous(limits = c(0, 1)) +
     facet_wrap(~ edema)
    
    ```

### Summarize ORSF models

Getting straight to variable importance and partial dependence in a direct way can often be helpful in exploratory analyses. When you want a lot of information for just a little code, `orsf_summarize_uni()` is the tool for you:

```{r}
orsf_summarize_uni(orsf_fit, 
                   n_variables = 5, 
                   pred_horizon = 365.25 * 5)
```

## What about the original ORSF?

The original ORSF (i.e., `obliqueRSF`) used `glmnet` to find linear combinations of inputs. `aorsf` allows users to implement this approach using the `orsf_control_net()` function: 

```{r}

orsf_net <- orsf(data = pbc_orsf, 
                 formula = Surv(time, status) ~ . - id, 
                 control = orsf_control_net(),
                 n_tree = 50)

```

`net` forests fit a lot faster than the original ORSF function in `obliqueRSF`. However, `net` forests are still much slower than `cph` ones:

```{r}

# tracking how long it takes to fit 50 glmnet trees
print(
 t1 <- system.time(
  orsf(data = pbc_orsf, 
       formula = Surv(time, status) ~ . - id, 
       control = orsf_control_net(),
       n_tree = 50)
 )
)

# and how long it takes to fit 50 cph trees
print(
 t2 <- system.time(
  orsf(data = pbc_orsf, 
       formula = Surv(time, status) ~ . - id, 
       control = orsf_control_cph(),
       n_tree = 50)
 )
)

t1['elapsed'] / t2['elapsed']


```

## aorsf and other machine learning software

Generally, `aorsf` follows conventions set by the R packages `randomForest` and `randomForestSRC`. For example, the `print` method for `aorsf` models is very similar to `randomForestSRC` models, as is the specification of computing variable importance and the objects returned by variable importance functions. Similar to `randomForestSRC`, `aorsf` allows and recommends partial dependence to be estimated using out-of-bag data. 

The unique feature of `aorsf` is fitting oblique random survival forests fast while maintaining strong prediction accuracy. `RLT` and `obliqueRSF` both fit oblique random survival forests, but `aorsf` does so faster. `ranger` and `randomForestSRC` fit survival forests, but neither package supports oblique splitting. `obliqueRF` fits oblique random forests for classification and regression, but not survival. `PPforest` fits oblique random forests for classification but not survival. The default prediction behavior for `aorsf` models is to produce predicted risk at a specific prediction horizon, which is not the default for `ranger`  or `randomForestSRC`.

