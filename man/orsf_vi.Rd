% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/orsf_vi.R
\name{orsf_vi}
\alias{orsf_vi}
\alias{orsf_vi_negate}
\alias{orsf_vi_permute}
\alias{orsf_vi_anova}
\title{ORSF variable importance}
\usage{
orsf_vi(
  object,
  group_factors = TRUE,
  importance = NULL,
  oobag_fun = NULL,
  n_thread = 1,
  verbose_progress = FALSE,
  ...
)

orsf_vi_negate(
  object,
  group_factors = TRUE,
  oobag_fun = NULL,
  n_thread = 1,
  verbose_progress = FALSE,
  ...
)

orsf_vi_permute(
  object,
  group_factors = TRUE,
  oobag_fun = NULL,
  n_thread = 1,
  verbose_progress = FALSE,
  ...
)

orsf_vi_anova(object, group_factors = TRUE, ...)
}
\arguments{
\item{object}{(\emph{ObliqueForest}) a trained oblique random forest object (see \link{orsf}).}

\item{group_factors}{(\emph{logical}) if \code{TRUE}, the importance of factor variables will be reported overall by aggregating the importance of individual levels of the factor. If \code{FALSE}, the importance of individual factor levels will be returned.}

\item{importance}{(\emph{character}) Indicate method for variable importance:
\itemize{
\item 'anova': compute analysis of variance (ANOVA) importance
\item 'negate': compute negation importance
\item 'permute': compute permutation importance
}}

\item{oobag_fun}{(\emph{function}) to be used for evaluating out-of-bag prediction accuracy after negating coefficients
(if importance = 'negate') or permuting the values of a predictor
(if importance = 'permute')
\itemize{
\item When \code{oobag_fun = NULL} (the default), the evaluation statistic is selected based on tree type
\item survival: Harrell's C-statistic (1982)
\item classification: Area underneath the ROC curve (AUC-ROC)
\item regression: Traditional prediction R-squared
\item if you use your own \code{oobag_fun} note the following:
\itemize{
\item \code{oobag_fun} should have three inputs: \code{y_mat}, \code{w_vec}, and \code{s_vec}
\item For survival trees, \code{y_mat} should be a two column matrix with first column named 'time' and second named 'status'. For classification trees, \code{y_mat} should be a matrix with number of columns = number of distinct classes in the outcome. For regression, \code{y_mat} should be a matrix with one column.
\item \code{s_vec} is a numeric vector containing predictions
\item \code{oobag_fun} should return a numeric output of length 1
\item the same \code{oobag_fun} should have been used when you created \code{object}
so that the initial value of out-of-bag prediction accuracy is
consistent with the values that will be computed while variable
importance is estimated.
}
}

For more details, see the out-of-bag
\href{https://docs.ropensci.org/aorsf/articles/oobag.html}{vignette}.}

\item{n_thread}{(\emph{integer}) number of threads to use while computing predictions. Default is one thread. To use the maximum number of threads that your system provides for concurrent execution, set \code{n_thread = 0}.}

\item{verbose_progress}{(\emph{logical}) if \code{TRUE}, progress messages are
printed in the console. If \code{FALSE} (the default), nothing is printed.}

\item{...}{Further arguments passed to or from other methods (not currently used).}
}
\value{
\code{orsf_vi} functions return a named numeric vector.
\itemize{
\item Names of the vector are the predictor variables used by \code{object}
\item Values of the vector are the estimated importance of the given predictor.
}

The returned vector is sorted from highest to lowest value, with higher
values indicating higher importance.
}
\description{
Estimate the importance of individual variables using oblique random
survival forests.
}
\details{
When an \code{ObliqueForest} object is grown with importance = 'anova',
'negate', or 'permute', the output will have a vector of importance
values based on the requested type of importance. However, \code{orsf_vi()}
can be used to compute variable importance after growing a forest
or to compute a different type of importance.

\code{orsf_vi()} is a general purpose function to extract or compute variable
importance estimates from an \code{ObliqueForest} object (see \link{orsf}).
\code{orsf_vi_negate()}, \code{orsf_vi_permute()}, and \code{orsf_vi_anova()} are wrappers
for \code{orsf_vi()}. The way these functions work depends on whether the
\code{object} they are given already has variable importance estimates in it
or not (see examples).
}
\section{Variable importance methods}{


\strong{negation importance}: Each variable is assessed separately by multiplying the variable's coefficients by -1 and then determining how much the model's performance changes. The worse the model's performance after negating coefficients for a given variable, the more important the variable. This technique is promising b/c it does not require permutation and it emphasizes variables with larger coefficients in linear combinations, but it is also relatively new and hasn't been studied as much as permutation importance. See Jaeger, (2023) for more details on this technique.

\strong{permutation importance}: Each variable is assessed separately by randomly permuting the variable's values and then determining how much the model's performance changes. The worse the model's performance after permuting the values of a given variable, the more important the variable. This technique is flexible, intuitive, and frequently used. It also has several \href{https://christophm.github.io/interpretable-ml-book/feature-importance.html#disadvantages-9}{known limitations}

\strong{analysis of variance (ANOVA) importance}: A p-value is computed for each coefficient in each linear combination of variables in each decision tree. Importance for an individual predictor variable is the proportion of times a p-value for its coefficient is < 0.01. This technique is very efficient computationally, but may not be as effective as permutation or negation in terms of selecting signal over noise variables. See \href{https://link.springer.com/chapter/10.1007/978-3-642-23783-6_29}{Menze, 2011} for more details on this technique.
}

\section{Examples}{
\subsection{ANOVA importance}{

The default variable importance technique, ANOVA, is calculated while
you fit an ORSF ensemble.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
fit <- orsf(pbc_orsf, Surv(time, status) ~ . - id)

fit
#> ---------- Oblique random survival forest
#> 
#>      Linear combinations: Accelerated Cox regression
#>           N observations: 276
#>                 N events: 111
#>                  N trees: 500
#>       N predictors total: 17
#>    N predictors per node: 5
#>  Average leaves per tree: 21.28
#> Min observations in leaf: 5
#>       Min events in leaf: 1
#>           OOB stat value: 0.84
#>            OOB stat type: Harrell's C-index
#>      Variable importance: anova
#> 
#> -----------------------------------------
}\if{html}{\out{</div>}}

ANOVA is the default because it is fast, but it may not be as decisive
as the permutation and negation techniques for variable selection.
}

\subsection{Raw VI values}{

the ‘raw’ variable importance values can be accessed from the fit object

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
attr(fit, 'importance_values')
#> NULL
}\if{html}{\out{</div>}}

these are ‘raw’ because values for factors have not been aggregated into
a single value. Currently there is one value for k-1 levels of a k level
factor. For example, you can see edema_1 and edema_0.5 in the importance
values above because edema is a factor variable with levels of 0, 0.5,
and 1.
}

\subsection{Collapse VI across factor levels}{

To get aggregated values across all levels of each factor,
\itemize{
\item access the \code{importance} element from the \code{orsf} fit:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
fit$importance
#>    ascites       bili      edema     copper    albumin        age    protime 
#> 0.48908730 0.40201927 0.31576154 0.28808594 0.25707434 0.24918491 0.23739599 
#>       chol      stage        ast    spiders     hepato        sex   alk.phos 
#> 0.22546673 0.20949432 0.17276227 0.17108825 0.15844298 0.15646688 0.11049164 
#>       trig   platelet        trt 
#> 0.10526316 0.08373905 0.07367336
}\if{html}{\out{</div>}}
\item use \code{orsf_vi()} with group_factors set to \code{TRUE} (the default)

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
orsf_vi(fit)
#>    ascites       bili      edema     copper    albumin        age    protime 
#> 0.48908730 0.40201927 0.31576154 0.28808594 0.25707434 0.24918491 0.23739599 
#>       chol      stage        ast    spiders     hepato        sex   alk.phos 
#> 0.22546673 0.20949432 0.17276227 0.17108825 0.15844298 0.15646688 0.11049164 
#>       trig   platelet        trt 
#> 0.10526316 0.08373905 0.07367336
}\if{html}{\out{</div>}}
}

Note that you can make the default returned importance values ungrouped
by setting \code{group_factors} to \code{FALSE} in the \code{orsf_vi} functions or the
\code{orsf} function.
}

\subsection{Add VI to an ORSF}{

You can fit an ORSF without VI, then add VI later

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
fit_no_vi <- orsf(pbc_orsf,
                  Surv(time, status) ~ . - id,
                  importance = 'none')

# Note: you can't call orsf_vi_anova() on fit_no_vi because anova
# VI can only be computed while the forest is being grown.

orsf_vi_negate(fit_no_vi)
#>         bili       copper          sex        stage      protime          age 
#> 0.1237139435 0.0522875916 0.0436374058 0.0264254542 0.0242211214 0.0208034497 
#>      albumin         chol      ascites          ast       hepato        edema 
#> 0.0203449935 0.0152155212 0.0134918141 0.0122755546 0.0080937907 0.0068807789 
#>      spiders     alk.phos          trt         trig     platelet 
#> 0.0058287217 0.0037382254 0.0024557752 0.0018237051 0.0006883272

orsf_vi_permute(fit_no_vi)
#>          bili        copper       protime         stage       ascites 
#>  0.0561427515  0.0237024406  0.0133988228  0.0125754046  0.0111755937 
#>       albumin           age          chol           ast         edema 
#>  0.0110805054  0.0108799933  0.0066262186  0.0062079536  0.0055363061 
#>       spiders        hepato           sex      alk.phos          trig 
#>  0.0053754874  0.0048894468  0.0038219855  0.0022462567  0.0009261366 
#>      platelet           trt 
#>  0.0007595733 -0.0012610217
}\if{html}{\out{</div>}}
}

\subsection{ORSF and VI all at once}{

fit an ORSF and compute vi at the same time

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
fit_permute_vi <- orsf(pbc_orsf,
                        Surv(time, status) ~ . - id,
                        importance = 'permute')

# get the vi instantly (i.e., it doesn't need to be computed again)
orsf_vi_permute(fit_permute_vi)
#>          bili        copper       protime           age       albumin 
#>  0.0556303145  0.0236357483  0.0142531459  0.0140897553  0.0117613116 
#>         stage       ascites          chol           ast       spiders 
#>  0.0113418077  0.0113139114  0.0058735307  0.0056767581  0.0052889836 
#>         edema        hepato          trig      alk.phos           sex 
#>  0.0050020021  0.0041316272  0.0019724136  0.0015504082  0.0014809407 
#>      platelet           trt 
#>  0.0004440263 -0.0001428931
}\if{html}{\out{</div>}}

You can still get negation VI from this fit, but it needs to be computed

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
orsf_vi_negate(fit_permute_vi)
#>         bili       copper          sex      protime        stage          age 
#> 0.1243138054 0.0512366504 0.0355333945 0.0245616522 0.0244816644 0.0220214226 
#>      albumin      ascites          ast         chol      spiders       hepato 
#> 0.0199297370 0.0116687313 0.0115769922 0.0113597854 0.0065500245 0.0064090827 
#>        edema          trt         trig     alk.phos     platelet 
#> 0.0061703318 0.0043143732 0.0041226791 0.0028748538 0.0007984187
}\if{html}{\out{</div>}}
}
}

\references{
Harrell FE, Califf RM, Pryor DB, Lee KL, Rosati RA. Evaluating the Yield of Medical Tests. \emph{JAMA} 1982; 247(18):2543-2546. DOI: 10.1001/jama.1982.03320430047030

Breiman L. Random forests. \emph{Machine learning} 2001 Oct; 45(1):5-32. DOI: 10.1023/A:1010933404324

Menze BH, Kelm BM, Splitthoff DN, Koethe U, Hamprecht FA. On oblique random forests. \emph{Joint European Conference on Machine Learning and Knowledge Discovery in Databases} 2011 Sep 4; pp. 453-469. DOI: 10.1007/978-3-642-23783-6_29

Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey A, Pajewski NM. Accelerated and interpretable oblique random survival forests. \emph{Journal of Computational and Graphical Statistics} Published online 08 Aug 2023. DOI: 10.1080/10618600.2023.2231048
}
