% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/orsf_vi.R
\name{orsf_vi}
\alias{orsf_vi}
\alias{orsf_vi_negate}
\alias{orsf_vi_permute}
\alias{orsf_vi_anova}
\title{ORSF variable importance}
\usage{
orsf_vi(object, group_factors = TRUE, importance = NULL, oobag_fun = NULL, ...)

orsf_vi_negate(object, group_factors = TRUE, oobag_fun = NULL, ...)

orsf_vi_permute(object, group_factors = TRUE, oobag_fun = NULL, ...)

orsf_vi_anova(object, group_factors = TRUE, ...)
}
\arguments{
\item{object}{(\emph{orsf_fit}) an oblique random survival forest (ORSF; see \link{orsf}).}

\item{group_factors}{(\emph{logical}) if \code{TRUE}, the importance of factor
variables will be reported overall by aggregating the importance
of individual levels of the factor. If \code{FALSE}, the importance of
individual factor levels will be returned.}

\item{importance}{(\emph{character}) Indicate method for variable importance:
\itemize{
\item 'anova': compute analysis of variance (ANOVA) importance
\item 'negate': compute negation importance
\item 'permute': compute permutation importance
}}

\item{oobag_fun}{(\emph{function}) to be used for evaluating out-of-bag prediction accuracy after negating coefficients
(if importance = 'negate') or permuting the values of a predictor
(if importance = 'permute')
\itemize{
\item When \code{oobag_fun = NULL} (the default), Harrell's C-statistic (1982) is used to evaluate accuracy.
\item if you use your own \code{oobag_fun} note the following:
\itemize{
\item \code{oobag_fun} should have two inputs: \code{y_mat} and \code{s_vec}
\item \code{y_mat} is a two column matrix with first column named 'time', second named 'status'
\item \code{s_vec} is a numeric vector containing predicted survival probabilities.
\item \code{oobag_fun} should return a numeric output of length 1
\item the same \code{oobag_fun} should have been used when you created \code{object}
so that the initial value of out-of-bag prediction accuracy is
consistent with the values that will be computed while variable
importance is estimated.
}
}

For more details, see the out-of-bag
\href{https://bcjaeger.github.io/aorsf/articles/oobag.html}{vignette}.}

\item{...}{Further arguments passed to or from other methods (not currently used).}
}
\value{
\code{orsf_vi} functions return a named numeric vector.
\itemize{
\item Names of the vector are the predictor variables used by \code{object}
\item Values of the vector are the estimated importance of the given predictor.
}

The returned vector is sorted from highest to lowest value, with higher
values indicating higher importance.
}
\description{
Estimate the importance of individual variables using oblique random
survival forests.
}
\details{
When an \code{orsf_fit} object is fitted with importance = 'anova', 'negate', or
'permute', the output will have a vector of importance values based on
the requested type of importance. However, you may still want to call
\code{orsf_vi()} on this output if you want to group factor levels into one
overall importance value.

\code{orsf_vi()} is a general purpose function to extract or compute variable
importance estimates from an \code{'orsf_fit'} object (see \link{orsf}).
\code{orsf_vi_negate()}, \code{orsf_vi_permute()}, and \code{orsf_vi_anova()} are wrappers
for \code{orsf_vi()}. The way these functions work depends on whether the
\code{object} they are given already has variable importance estimates in it
or not (see examples).
}
\section{Variable importance methods}{


\strong{negation importance}: Each variable is assessed separately by
multiplying the variable's coefficients by -1 and then determining
how much the model's performance changes. The worse the model's
performance after negating coefficients for a given variable,
the more important the variable.

\strong{permutation importance}: Each variable is assessed separately by
randomly permuting the variable's values and then determining
how much the model's performance changes. The worse the model's
performance after permuting the values of a given variable,
the more important the variable.

\strong{analysis of variance (ANOVA) importance}: computes a p-value for each
coefficient in each linear combination of variables in each decision
tree of an oblique random forest. Following the definition proposed by
Menze et al, ANOVA importance for an individual predictor variable is
the proportion of times a p-value for its coefficient is < 0.01.
}

\examples{

# first example ----------------------------------------------------------

# fit an ORSF using default values, and get the default vi (anova)

fit_default <- orsf(pbc_orsf,
                    Surv(time, status) ~ . - id)

# the printed output will indicate the type of vi used

fit_default

# the 'raw' vi values are stored in fit_default:

fit_default$importance

# these are 'raw' because the vi values for factors have not been
# aggregated into a single vi value. Currently there is one vi value
# for k-1 levels of a k level factor. For example, you can see edema_1
# and edema_0.5 in the importance values above because edema is a factor
# variable with levels of 0, 0.5, and 1. To get aggregated values of vi
# across all levels of each factor, just call orsf_vi with group_factors
# set to TRUE (the default)

orsf_vi(fit_default)

# orsf_vi knows that fit_default was fit using anova vi
# to verify this, see that orsf_vi and orsf_vi_anova are the same

orsf_vi_anova(fit_default)


# second example ---------------------------------------------------------

# fit an ORSF without vi, then add vi later

fit_no_vi <- orsf(pbc_orsf,
                  Surv(time, status) ~ . - id,
                  importance = 'none')

# Note: you can't call orsf_vi_anova() on fit_no_vi because anova
# VI can only be computed while the forest is being grown.

orsf_vi_negate(fit_no_vi)

orsf_vi_permute(fit_no_vi)

# third example ----------------------------------------------------------

# fit an ORSF and compute vi at the same time

fit_permute_vi <- orsf(pbc_orsf,
                       Surv(time, status) ~ . - id,
                       importance = 'permute')

# get the vi instantly (i.e., it doesn't need to be computed again)

orsf_vi_permute(fit_permute_vi)

# You can still get negation vi from this fit, but it needs to be computed

orsf_vi_negate(fit_permute_vi)


}
\references{
Harrell FE, Califf RM, Pryor DB, Lee KL, Rosati RA. Evaluating the Yield of Medical Tests. \emph{JAMA} 1982; 247(18):2543-2546. DOI: 10.1001/jama.1982.03320430047030

Breiman L. Random forests. \emph{Machine learning} 2001 Oct; 45(1):5-32. DOI: 10.1023/A:1010933404324

Menze BH, Kelm BM, Splitthoff DN, Koethe U, Hamprecht FA. Joint European Conference on Machine Learning and Knowledge Discovery in Databases. \emph{JAMA} 2011 Sep 4; pp. 453-469. DOI: 10.1007/978-3-642-23783-6_29

Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey A, Pajewski NM. Accelerated and interpretable oblique random survival forests. \emph{arXiv e-prints} 2022 Aug; arXiv-2208. URL: https://arxiv.org/abs/2208.01129
}
