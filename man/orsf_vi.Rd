% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/orsf_vi.R
\name{orsf_vi}
\alias{orsf_vi}
\alias{orsf_vi_negate}
\alias{orsf_vi_permute}
\alias{orsf_vi_anova}
\title{ORSF variable importance}
\usage{
orsf_vi(object, group_factors = TRUE, importance = NULL, oobag_fun = NULL, ...)

orsf_vi_negate(object, group_factors = TRUE, oobag_fun = NULL, ...)

orsf_vi_permute(object, group_factors = TRUE, oobag_fun = NULL, ...)

orsf_vi_anova(object, group_factors = TRUE, ...)
}
\arguments{
\item{object}{an object of class 'aorsf'.}

\item{group_factors}{(\emph{logical}) if \code{TRUE}, the importance of factor
variables will be reported overall by aggregating the importance
of individual levels of the factor. If \code{FALSE}, the importance of
individual factor levels will be returned.}

\item{importance}{(\emph{character}) Indicate method for variable importance:
\itemize{
\item 'none': no variable importance is computed.
\item 'anova': use the analysis of variance (ANOVA) method
\item 'negate': compute negation importance
\item 'permute': compute permutation importance
}}

\item{oobag_fun}{(\emph{function}) When \code{oobag_fun} = \code{NULL} (the default),
out-of-bag predictions are evaluated using Harrell's C-statistic.
If a value for \code{oobag_fun} is provided, it will be used in place of
Harrell's C-statistic to evaluate out-of-bag predictions. See details.}

\item{...}{not currently used.}
}
\value{
a named vector. Names indicate predictors, values indicate importance.
The vector is sorted from highest to lowest value, with higher values
indicating higher importance.
}
\description{
Estimate the importance of individual variables using oblique random
survival forests. \code{orsf_vi()} is a general purpose function to extract
or compute variable importance (VI) estimates from an \code{aorsf} object
(see \link{orsf}). The three functions \code{orsf_vi_negate()}, \code{orsf_vi_permute()},
and \code{orsf_vi_anova()} are convenient wrappers for \code{orsf_vi()}. The
way these functions work depends on whether the \code{object} they are
given already has VI estimates in it or not (see examples).
}
\details{
\strong{negation importance}: Each variable is assessed separately by
multiplying the variable's coefficients by -1 and then determining
how much the model's performance changes. The worse the model's
performance after negating coefficients for a given variable,
the more important the variable.

\strong{permutation importance}: Each variable is assessed separately by
randomly permuting the variable's values and then determining
how much the model's performance changes. The worse the model's
performance after permuting the values of a given variable,
the more important the variable.

\strong{ANOVA importance}: ANOVA importance computes a p-value for each
coefficient in each linear combination of variables in each decision
tree of an oblique random forest. Following the definition proposed by
Menze et al, ANOVA importance in aorsf for an individual variable is
the proportion of times a p-value for its coefficient is < 0.01.
}
\examples{

# first workflow -------------------------------------------------------------
# fit an aorsf object using default values, and get the default vi (anova)

fit_default <- orsf(pbc_orsf,
                    Surv(time, status) ~ . - id)

# the printed output will indicate the type of vi used

fit_default

# the 'raw' vi values are stored in fit_default:

fit_default$importance

# these are 'raw' because the vi values for factors have not been
# aggregated into a single vi value. Currently there is one vi value
# for k-1 levels of a k level factor. For example, you can see edema_1
# and edema_0.5 in the importance values above because edema is a factor
# variable with levels of 0, 0.5, and 1. To get aggregated values of vi
# across all levels of each factor, just call orsf_vi with group_factors
# set to TRUE (the default)

orsf_vi(fit_default)

# orsf_vi knows that fit_default was fit using anova vi
# to verify this, see that orsf_vi and orsf_vi_anova are the same

orsf_vi_anova(fit_default)



# second workflow ------------------------------------------------------------
# fit an aorsf object without vi, then add vi later

fit_no_vi <- orsf(pbc_orsf,
                  Surv(time, status) ~ . - id,
                  importance = 'none')

# Note: you can't call orsf_vi_anova() on fit_no_vi because anova
# VI can only be computed while the forest is being grown.

orsf_vi_negate(fit_no_vi)

orsf_vi_permute(fit_no_vi)

# third workflow ------------------------------------------------------------
# fit an aorsf object and compute vi at the same time

fit_permute_vi <- orsf(pbc_orsf,
                       Surv(time, status) ~ . - id,
                       importance = 'permute')

# get the vi instantly (i.e., it doesn't need to be computed again)

orsf_vi_permute(fit_permute_vi)

# You can still get negation vi from this fit, but it needs to be computed

orsf_vi_negate(fit_permute_vi)


}
\references{
Menze, Bjoern H., et al. On oblique random forests.
\emph{Joint European Conference on Machine Learning and Knowledge Discovery in Databases}.
Springer, Berlin, Heidelberg, 2011.
DOI: 10.1007/978-3-642-23783-6_29

Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey A, Pajewski NM.
\emph{Accelerated and interpretable oblique random survival forests.}
arXiv e-prints. 2022 Aug 3:arXiv-2208. URL: https://arxiv.org/abs/2208.01129
}
