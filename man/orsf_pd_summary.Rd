% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/orsf_pd.R
\name{orsf_pd_summary}
\alias{orsf_pd_summary}
\alias{orsf_pd_ice}
\title{ORSF partial dependence}
\usage{
orsf_pd_summary(
  object,
  pd_data = NULL,
  pd_spec,
  pred_horizon = NULL,
  pred_type = "risk",
  expand_grid = TRUE,
  prob_values = c(0.025, 0.5, 0.975),
  prob_labels = c("lwr", "medn", "upr"),
  oobag = TRUE,
  boundary_checks = TRUE,
  ...
)

orsf_pd_ice(
  object,
  pd_data = NULL,
  pd_spec,
  pred_horizon = NULL,
  pred_type = "risk",
  expand_grid = TRUE,
  oobag = TRUE,
  boundary_checks = TRUE,
  ...
)
}
\arguments{
\item{object}{(\emph{orsf_fit}) a trained oblique random survival forest
(see \link{orsf}).}

\item{pd_data}{(\emph{data frame}) that will be used to compute partial
dependence. If \code{NULL}, then the training data of \code{object} will be
used. If the training data were not attached to \code{object}
(see \code{attach_data} input in \link{orsf}), an error will be triggered.}

\item{pd_spec}{(\emph{named list} or \emph{data.frame}).
\itemize{
\item If \code{pd_spec} is a named list,
Each item in the list should be a vector of values that will be used as
points in the partial dependence function. The name of each item in the
list should indicate which variable will be modified to take the
corresponding values.
\item If \code{pd_spec} is a \code{data.frame}, columns will
indicate variable names, values will indicate variable values, and
partial dependence will be computed using the inputs on each row.
}}

\item{pred_horizon}{(\emph{double}) a value or vector indicating the time(s)
that predictions will be calibrated to. E.g., if you were predicting
risk of incident heart failure within the next 10 years, then
\code{pred_horizon = 10}}

\item{pred_type}{(\emph{character}) the type of predictions to return. Valid
options are
\itemize{
\item 'risk' : probability of having an event at or before \code{pred_horizon}.
\item 'survival' : 1 - risk.
}}

\item{expand_grid}{(\emph{logical}) if \code{TRUE}, partial dependence will be
computed at all possible combinations of inputs in \code{pd_spec}. If
\code{FALSE}, partial dependence will be computed for each variable
in \code{pd_spec}, separately.}

\item{prob_values}{(\emph{numeric}) a vector of values between 0 and 1,
indicating what quantiles will be used to summarize the partial
dependence values at each set of inputs. \code{prob_values} should
have the same length as \code{prob_labels}. The quantiles are calculated
based on predictions from \code{object} at each set of values indicated
by \code{pd_spec}.}

\item{prob_labels}{(\emph{character}) a vector of labels with the same length
as \code{prob_values}, with each label indicating what the corresponding
value in \code{prob_values} should be labelled as in summarized outputs.
\code{prob_labels} should have the same length as \code{prob_values}.}

\item{oobag}{(\emph{logical}) if \code{TRUE}, then partial dependence will be
computed using the out of bag training data. You should set
\code{oobag = TRUE} if you are computing partial dependence using the
training data for \code{object}.}

\item{boundary_checks}{(\emph{logical}) if \code{TRUE}, \code{pd_spec} will be vetted
to make sure the requested values are between the 10th and 90th
percentile in the object's training data. If \code{FALSE}, these checks are
skipped.}

\item{...}{Further arguments passed to or from other methods (not currently used).}
}
\value{
a \code{data.table} containing
\itemize{
\item \code{orsf_pd_ice}: individual conditional expectation (ICE) values.
\item \code{orsf_pd_summary}: summarized ICE values (i.e., partial dependence).
}
}
\description{
ORSF partial dependence
}
\examples{

fit <- orsf(pbc_orsf, Surv(time, status) ~ . - id)

orsf_pd_summary(fit, pd_spec = list(bili = c(1,2,3,4,5,6)), pred_horizon = 1000)

# more points for a plot
pd_spec <- list(bili = seq(1, 6, length.out = 20))
data_ice <- orsf_pd_ice(fit, pd_spec = pd_spec, pred_horizon = c(1000))

head(data_ice)

library(ggplot2)

ggplot(data_ice) +
 aes(x = bili, y = pred, group = id_row) +
 geom_line(alpha = 0.4, color = 'grey') +
 geom_smooth(aes(group = 1), color = 'black', se = FALSE) +
 theme_bw() +
 theme(panel.grid = element_blank())
}
