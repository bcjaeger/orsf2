% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/orsf_control.R
\name{orsf_control}
\alias{orsf_control}
\alias{orsf_control_classification}
\alias{orsf_control_regression}
\alias{orsf_control_survival}
\title{Oblique random forest control}
\usage{
orsf_control(
  tree_type,
  method,
  scale_x,
  ties,
  net_mix,
  target_df,
  max_iter,
  epsilon,
  ...
)

orsf_control_classification(
  method = "glm",
  scale_x = TRUE,
  net_mix = 0.5,
  target_df = NULL,
  max_iter = 20,
  epsilon = 1e-09,
  ...
)

orsf_control_regression(
  method = "glm",
  scale_x = TRUE,
  net_mix = 0.5,
  target_df = NULL,
  max_iter = 20,
  epsilon = 1e-09,
  ...
)

orsf_control_survival(
  method = "glm",
  scale_x = TRUE,
  ties = "efron",
  net_mix = 0.5,
  target_df = NULL,
  max_iter = 20,
  epsilon = 1e-09,
  ...
)
}
\arguments{
\item{tree_type}{(\emph{character}) the type of tree. Valid options are
\itemize{
\item "classification", i.e., categorical outcomes
\item "regression", i.e., continuous outcomes
\item "survival", i.e., time-to event outcomes
}}

\item{method}{(\emph{character} or \emph{function}) how to identify linear
linear combinations of predictors. If \code{method} is a character value,
it must be one of:
\itemize{
\item 'glm': linear, logistic, and cox regression
\item 'net': same as 'glm' but with penalty terms
\item 'pca': principal component analysis
\item 'random': random draw from uniform distribution
}

If \code{method} is a \emph{function}, it will be used to identify  linear
combinations of predictor variables. \code{method} must in this case accept
three inputs named \code{x_node}, \code{y_node} and \code{w_node}, and should expect
the following types and dimensions:
\itemize{
\item \code{x_node} (\emph{matrix}; \code{n} rows, \code{p} columns)
\item \code{y_node} (\emph{matrix}; \code{n} rows, \code{2} columns)
\item \code{w_node} (\emph{matrix}; \code{n} rows, \code{1} column)
}

In addition, \code{method} must return a matrix with p rows and 1 column.}

\item{scale_x}{(\emph{logical}) if \code{TRUE}, values of predictors will be
scaled prior to each instance of finding a linear combination of
predictors, using summary values from the data in the current node
of the decision tree.}

\item{ties}{(\emph{character}) a character string specifying the method
for tie handling. Only relevant when modeling survival outcomes
and using a method that engages with tied outcome times.
If there are no ties, all the methods are equivalent. Valid options
are 'breslow' and 'efron'. The Efron approximation is the default
because it is more accurate when dealing with tied event times and
has similar computational efficiency compared to the Breslow method.}

\item{net_mix}{(\emph{double}) The elastic net mixing parameter. A value of 1
gives the lasso penalty, and a value of 0 gives the ridge penalty. If
multiple values of alpha are given, then a penalized model is fit using
each alpha value prior to splitting a node.}

\item{target_df}{(\emph{integer}) Preferred number of variables used in each
linear combination. For example, with \code{mtry} of 5 and \code{target_df} of 3,
we sample 5 predictors and look for the best linear combination using
3 of them.}

\item{max_iter}{(\emph{integer}) iteration continues until convergence
(see \code{eps} above) or the number of attempted iterations is equal to
\code{iter_max}.}

\item{epsilon}{(\emph{double}) When using most modeling based method,
iteration continues in the algorithm until the relative change in
some kind of objective is less than \code{epsilon}, or the absolute
change is less than \code{sqrt(epsilon)}.}

\item{...}{Further arguments passed to or from other methods (not currently used).}
}
\value{
an object of class \code{'orsf_control'}, which should be used as
an input for the \code{control} argument of \link{orsf}. Components are:
\itemize{
\item \code{tree_type}: type of trees to fit
\item \code{lincomb_type}: method for linear combinations
\item \code{lincomb_eps}: epsilon for convergence
\item \code{lincomb_iter_max}: max iterations
\item \code{lincomb_scale}: to scale or not.
\item \code{lincomb_alpha}: mixing parameter
\item \code{lincomb_df_target}: target degrees of freedom
\item \code{lincomb_ties_method}: method for ties in survival time
\item \code{lincomb_R_function}: R function for custom splits
}
}
\description{
Oblique random forest control
}
\details{
Adjust \code{scale_x} \emph{at your own risk}. Setting \code{scale_x = FALSE} will
reduce computation time but will also make the \code{orsf} model dependent
on the scale of your data, which is why the default value is \code{TRUE}.
}
\examples{

orsf_control_classification()
orsf_control_regression()
orsf_control_survival()

}
