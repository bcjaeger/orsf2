[{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to aorsf","title":"Contributing to aorsf","text":"Want contribute aorsf? Great! aorsf initially stable state development, great deal active subsequent development envisioned. outline propose change aorsf. detailed info contributing , tidyverse packages, please see development contributing guide.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to aorsf","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to aorsf","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to aorsf","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"ropensci/aorsf\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to aorsf","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to aorsf","text":"Please note aorsf project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://bcjaeger.github.io/aorsf/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 aorsf authors (Byron C. Jaeger, Sawyer Welden, Nicholas M. Pajewski) Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"background-orsf","dir":"Articles","previous_headings":"","what":"Background: ORSF","title":"Introduction to aorsf","text":"oblique random survival forest (ORSF) extension axis-based RSF algorithm. See orsf details ORSFs. see JCGS paper details algorithms used specifically aorsf.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"accelerated-orsf","dir":"Articles","previous_headings":"","what":"Accelerated ORSF","title":"Introduction to aorsf","text":"purpose aorsf (‘’ short accelerated) provide routines fit ORSFs scale adequately large data sets. fastest algorithm available package accelerated ORSF model, default method used orsf(): may notice first input aorsf data. design choice makes easier use orsf pipes (.e., %>% |>). instance,","code":"library(aorsf)  set.seed(329)  orsf_fit <- orsf(data = pbc_orsf,                   formula = Surv(time, status) ~ . - id)  orsf_fit #> ---------- Oblique random survival forest #>  #>      Linear combinations: Accelerated Cox regression #>           N observations: 276 #>                 N events: 111 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 21 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.84 #>            OOB stat type: Harrell's C-statistic #>      Variable importance: anova #>  #> ----------------------------------------- library(dplyr)  orsf_fit <- pbc_orsf |>   select(-id) |>   orsf(formula = Surv(time, status) ~ .)"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"interpretation","dir":"Articles","previous_headings":"","what":"Interpretation","title":"Introduction to aorsf","text":"aorsf includes several functions dedicated interpretation ORSFs, estimation partial dependence variable importance.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"variable-importance","dir":"Articles","previous_headings":"Interpretation","what":"Variable importance","title":"Introduction to aorsf","text":"aorsf provides multiple ways compute variable importance. compute negation importance, ORSF multiplies coefficient variable -1 re-computes --sample (sometimes referred --bag) accuracy ORSF model. can also compute variable importance using permutation, classical approach. faster alternative permutation negation importance ANOVA importance, computes proportion times variable obtains low p-value (p < 0.01) forest grown.","code":"orsf_vi_negate(orsf_fit) #>         bili       copper          sex        stage      protime      albumin  #> 0.1269333300 0.0471985360 0.0360365677 0.0243587309 0.0241708554 0.0225453236  #>          age         chol      ascites          ast      spiders        edema  #> 0.0213716886 0.0153575882 0.0139061009 0.0116817406 0.0075489002 0.0070203635  #>       hepato          trt     alk.phos         trig     platelet  #> 0.0049274049 0.0039949547 0.0034672829 0.0030764514 0.0004390764 orsf_vi_permute(orsf_fit) #>          bili        copper       protime       albumin       ascites  #>  0.0572634486  0.0230199191  0.0133977370  0.0128399789  0.0126925475  #>           age         stage          chol           ast       spiders  #>  0.0125845408  0.0114992408  0.0074376943  0.0065136448  0.0059747612  #>         edema        hepato           sex      alk.phos          trig  #>  0.0050913001  0.0026642521  0.0024517816  0.0011030094  0.0006337896  #>           trt      platelet  #> -0.0002731314 -0.0008234638 orsf_vi_anova(orsf_fit) #>    ascites       bili     copper      edema    albumin        age    protime  #> 0.49453823 0.42999054 0.30285438 0.30172086 0.25564632 0.25478301 0.24861878  #>      stage       chol        ast     hepato    spiders        sex       trig  #> 0.20975354 0.19204981 0.17066015 0.16363636 0.16357504 0.14437500 0.13601630  #>   alk.phos   platelet        trt  #> 0.10744986 0.08044316 0.07594937"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"partial-dependence-pd","dir":"Articles","previous_headings":"Interpretation","what":"Partial dependence (PD)","title":"Introduction to aorsf","text":"Partial dependence (PD) shows expected prediction model function single predictor multiple predictors. expectation marginalized values predictors, giving something like multivariable adjusted estimate model’s prediction. PD, see vignette","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"individual-conditional-expectations-ice","dir":"Articles","previous_headings":"Interpretation","what":"Individual conditional expectations (ICE)","title":"Introduction to aorsf","text":"Unlike partial dependence, shows expected prediction function one multiple predictors, individual conditional expectations (ICE) show prediction individual observation function predictor. ICE, see vignette","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"what-about-the-original-orsf","dir":"Articles","previous_headings":"","what":"What about the original ORSF?","title":"Introduction to aorsf","text":"original ORSF (.e., obliqueRSF) used glmnet find linear combinations inputs. aorsf allows users implement approach using orsf_control_net() function: net forests fit lot faster original ORSF function obliqueRSF. However, net forests still much slower cph ones:","code":"orsf_net <- orsf(data = pbc_orsf,                   formula = Surv(time, status) ~ . - id,                   control = orsf_control_net(),                  n_tree = 50) # tracking how long it takes to fit 50 glmnet trees print(  t1 <- system.time(   orsf(data = pbc_orsf,         formula = Surv(time, status) ~ . - id,         control = orsf_control_net(),        n_tree = 50)  ) ) #>    user  system elapsed  #>   4.326   0.000   4.330  # and how long it takes to fit 50 cph trees print(  t2 <- system.time(   orsf(data = pbc_orsf,         formula = Surv(time, status) ~ . - id,         control = orsf_control_cph(),        n_tree = 50)  ) ) #>    user  system elapsed  #>   0.047   0.000   0.047  t1['elapsed'] / t2['elapsed'] #>  elapsed  #> 92.12766"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"aorsf-and-other-machine-learning-software","dir":"Articles","previous_headings":"","what":"aorsf and other machine learning software","title":"Introduction to aorsf","text":"unique feature aorsf fast algorithms fit ORSF ensembles. RLT obliqueRSF fit oblique random survival forests, aorsf faster. ranger randomForestSRC fit survival forests, neither package supports oblique splitting. obliqueRF fits oblique random forests classification regression, survival. PPforest fits oblique random forests classification survival. Note: default prediction behavior aorsf models produce predicted risk specific prediction horizon, default ranger randomForestSRC. think change future, computing time independent predictions aorsf helpful.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/fast.html","id":"go-faster","dir":"Articles","previous_headings":"","what":"Go faster","title":"Tips to speed up computation","text":"Analyses can slow crawl models need hours run. article find tricks prevent bottleneck using orsf(). ’ll use flchain data survival demonstrate. flc data 7871 rows 11 columns:","code":"data(\"flchain\", package = 'survival')  flc <- flchain # do this to avoid orsf() throwing an error about time to event = 0 flc <- flc[flc$futime > 0, ] # modify names  names(flc)[names(flc) == 'futime'] <- 'time' names(flc)[names(flc) == 'death'] <- 'status' head(flc) #>   age sex sample.yr kappa lambda flc.grp creatinine mgus time status #> 1  97   F      1997  5.70  4.860      10        1.7    0   85      1 #> 2  92   F      2000  0.87  0.683       1        0.9    0 1281      1 #> 3  94   F      1997  4.36  3.850      10        1.4    0   69      1 #> 4  92   F      1996  2.42  2.220       9        1.0    0  115      1 #> 5  93   F      1996  1.32  1.690       6        1.1    0 1039      1 #> 6  90   F      1997  2.01  1.860       9        1.0    0 1355      1 #>       chapter #> 1 Circulatory #> 2   Neoplasms #> 3 Circulatory #> 4 Circulatory #> 5 Circulatory #> 6      Mental"},{"path":"https://bcjaeger.github.io/aorsf/articles/fast.html","id":"use-orsf_control_fast","dir":"Articles","previous_headings":"","what":"Use orsf_control_fast()","title":"Tips to speed up computation","text":"default control value orsf() run-time compared approaches can striking. example:","code":"time_fast <- system.time(  expr = orsf(flc, time+status~., na_action = 'na_impute_meanmode',              control = orsf_control_fast(), n_tree = 10) )  time_net <- system.time(  expr = orsf(flc, time+status~., na_action = 'na_impute_meanmode',              control = orsf_control_net(), n_tree = 10) )  # control_fast() is much faster time_net['elapsed'] / time_fast['elapsed'] #>  elapsed  #> 34.41392"},{"path":"https://bcjaeger.github.io/aorsf/articles/fast.html","id":"use-n_thread","dir":"Articles","previous_headings":"","what":"Use n_thread","title":"Tips to speed up computation","text":"n_thread argument uses multi-threading run aorsf functions parallel possible. know many threads want, e.g. want exactly 5, just say n_thread = 5. aren’t sure many threads available want use many can, say n_thread = 0 aorsf figure number . R single threaded language, multi-threading applied orsf() needs call R functions C++, occurs customized R function used find linear combination variables compute prediction accuracy.","code":"time_1_thread <- system.time(  expr = orsf(flc, time+status~., na_action = 'na_impute_meanmode',              n_thread = 1, n_tree = 500) )  time_5_thread <- system.time(  expr = orsf(flc, time+status~., na_action = 'na_impute_meanmode',              n_thread = 5, n_tree = 500) )  time_auto_thread <- system.time(  expr = orsf(flc, time+status~., na_action = 'na_impute_meanmode',              n_thread = 0, n_tree = 500) )  # 5 threads and auto thread are both about 3 times faster than one thread  time_1_thread['elapsed'] / time_5_thread['elapsed'] #>   elapsed  #> 0.4075429 time_1_thread['elapsed'] / time_auto_thread['elapsed'] #>   elapsed  #> 0.7957501"},{"path":"https://bcjaeger.github.io/aorsf/articles/fast.html","id":"do-less","dir":"Articles","previous_headings":"","what":"Do less","title":"Tips to speed up computation","text":"defaults orsf() can adjusted make run faster: set n_retry 0 instead 3 (default) set oobag_pred_type ‘none’ instead ‘surv’ (default) set ‘importance’ ‘none’ instead ‘anova’ (default) increase split_min_events, split_min_obs, leaf_min_events, leaf_min_obs make trees stop growing sooner increase split_min_stat make trees stop growing sooner Applying tips: default values make orsf() run slower, also usually make predictions accurate make fit easier interpret.","code":"time_lightweight <- system.time(  expr = orsf(flc, time+status~., na_action = 'na_impute_meanmode',              n_thread = 0, n_tree = 500, n_retry = 0,              oobag_pred_type = 'none', importance = 'none',              split_min_events = 20, leaf_min_events = 10,              split_min_stat = 10) )  # about two times faster than auto thread with defaults time_auto_thread['elapsed'] / time_lightweight['elapsed'] #>  elapsed  #> 2.215503"},{"path":"https://bcjaeger.github.io/aorsf/articles/fast.html","id":"show-progress","dir":"Articles","previous_headings":"","what":"Show progress","title":"Tips to speed up computation","text":"Setting verbose_progress = TRUE doesn’t make anything run faster, can help make feel like things running less slow.","code":"verbose_fit <- orsf(flc, time+status~.,                      na_action = 'na_impute_meanmode',                     n_thread = 0,                      n_tree = 500,                      verbose_progress = TRUE) #> Growing trees: 20%. ~ time remaining: 8 seconds. #> Growing trees: 39%. ~ time remaining: 6 seconds. #> Growing trees: 58%. ~ time remaining: 4 seconds. #> Growing trees: 80%. ~ time remaining: 2 seconds. #> Growing trees: 97%. ~ time remaining: 0 seconds. #> Growing trees: 100%.  #> Computing predictions: 100%."},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"out-of-bag-data","dir":"Articles","previous_headings":"","what":"Out-of-bag data","title":"Out-of-bag predictions and evaluation","text":"random forests, tree grown bootstrapped version training set. bootstrap samples selected replacement, bootstrapped training set contains two-thirds instances original training set. ‘--bag’ data instances bootstrapped training set.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"out-of-bag-predictions-and-error","dir":"Articles","previous_headings":"","what":"Out-of-bag predictions and error","title":"Out-of-bag predictions and evaluation","text":"tree random forest can make predictions --bag data, --bag predictions can aggregated make ensemble --bag prediction. Since --bag data used grow tree, accuracy ensemble --bag predictions approximate generalization error random forest. --bag prediction error plays central role routines estimate variable importance, e.g. negation importance. Let’s fit oblique random survival forest plot distribution ensemble --bag predictions.  surprisingly, survival predictions 0 1. Next, let’s check --bag accuracy fit: --bag estimate Harrell’s C-statistic (default method evaluate --bag predictions) 0.8427522.","code":"fit <- orsf(data = pbc_orsf,              formula = Surv(time, status) ~ . - id,             oobag_pred_type = 'surv',             oobag_pred_horizon = 2000)  hist(fit$pred_oobag,       main = 'Ensemble out-of-bag survival predictions at t=3,500') # what function is used to evaluate out-of-bag predictions? fit$eval_oobag$stat_type #> [1] \"Harrell's C-statistic\"  # what is the output from this function? fit$eval_oobag$stat_values #>           [,1] #> [1,] 0.8427522"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"monitoring-out-of-bag-error","dir":"Articles","previous_headings":"","what":"Monitoring out-of-bag error","title":"Out-of-bag predictions and evaluation","text":"--bag data set contains one-third training set, --bag error estimate usually converges stable value trees added forest. want monitor convergence --bag error oblique random survival forest, can set oobag_eval_every compute --bag error every oobag_eval_every tree. example, let’s compute --bag error fitting tree forest 50 trees:  general, least 500 trees recommended random forest fit. ’re just using 50 case better illustration --bag error curve. Also, helps make run-times low whenever need re-compile package vignettes.","code":"fit <- orsf(data = pbc_orsf,             formula = Surv(time, status) ~ . - id,             n_tree = 50,             oobag_pred_type = 'surv',             oobag_pred_horizon = 2000,             oobag_eval_every = 1)  plot(  x = seq(1, 50, by = 1),  y = fit$eval_oobag$stat_values,   main = 'Out-of-bag C-statistic computed after each new tree is grown.',  xlab = 'Number of trees grown',  ylab = fit$eval_oobag$stat_type )"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"user-supplied-out-of-bag-evaluation-functions","dir":"Articles","previous_headings":"","what":"User-supplied out-of-bag evaluation functions","title":"Out-of-bag predictions and evaluation","text":"cases, may want control --bag error estimated. example, let’s use Brier score SurvMetrics package: two ways apply function compute --bag error. First, can apply function --bag survival predictions stored ‘aorsf’ objects, e.g: Second, can pass function orsf(), used place Harrell’s C-statistic:  can also compute time-dependent C-statistic instead Harrell’s C-statistic (default oob function):","code":"oobag_fun_brier <- function(y_mat, w_vec, s_vec){   # output is numeric vector of length 1  as.numeric(   SurvMetrics::Brier(    object = Surv(time = y_mat[, 1], event = y_mat[, 2]),     pre_sp = s_vec,    # t_star in Brier() should match oob_pred_horizon in orsf()    t_star = 2000   )  )   } oobag_fun_brier(y_mat = pbc_orsf[,c('time', 'status')],                 s_vec = fit$pred_oobag) #> [1] 0.114686 fit <- orsf(data = pbc_orsf,             formula = Surv(time, status) ~ . - id,             n_tree = 50,             oobag_pred_horizon = 2000,             oobag_fun = oobag_fun_brier,             oobag_eval_every = 1)  plot(  x = seq(1, 50, by = 1),  y = fit$eval_oobag$stat_values,   main = 'Out-of-bag error computed after each new tree is grown.',  sub = 'For the Brier score, lower values indicate more accurate predictions',  xlab = 'Number of trees grown',  ylab = \"Brier score\" ) oobag_fun_tdep_cstat <- function(y_mat, w_vec, s_vec){   as.numeric(   SurvMetrics::Cindex(    object = Surv(time = y_mat[, 1], event = y_mat[, 2]),     predicted = s_vec,    t_star = 2000   )  )  }  fit <- orsf(data = pbc_orsf,             formula = Surv(time, status) ~ . - id,             n_tree = 50,             oobag_pred_horizon = 2000,             oobag_fun = oobag_fun_tdep_cstat,             oobag_eval_every = 1)  plot(  x = seq(50),  y = fit$eval_oobag$stat_values,   main = 'Out-of-bag time-dependent AUC\\ncomputed after each new tree is grown.',  xlab = 'Number of trees grown',  ylab = \"AUC at t = 2,000\" )"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"specific-instructions-on-user-supplied-functions","dir":"Articles","previous_headings":"User-supplied out-of-bag evaluation functions","what":"Specific instructions on user-supplied functions","title":"Out-of-bag predictions and evaluation","text":"User-supplied functions must: exactly three arguments named y_mat, w_vec, s_vec. return numeric output length 1 either conditions true, error occur. simple test make sure user-supplied function work aorsf package :","code":"# Helper code to make sure your oobag_fun function will work with aorsf  # time and status values test_time <- seq(from = 1, to = 5, length.out = 100) test_status <- rep(c(0,1), each = 50)  # y-matrix is presumed to contain time and status (with column names) y_mat <- cbind(time = test_time, status = test_status) # s_vec is presumed to be a vector of survival probabilities s_vec <- seq(0.9, 0.1, length.out = 100)  # see 1 in the checklist above names(formals(oobag_fun_tdep_cstat)) == c(\"y_mat\", \"w_vec\", \"s_vec\") #> [1] TRUE TRUE TRUE  test_output <- oobag_fun_tdep_cstat(y_mat = y_mat,                                      w_vec = w_vec,                                     s_vec = s_vec)  # test output should be numeric is.numeric(test_output) #> [1] TRUE # test_output should be a numeric value of length 1 length(test_output) == 1 #> [1] TRUE"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"user-supplied-functions-for-negation-importance-","dir":"Articles","previous_headings":"","what":"User-supplied functions for negation importance.","title":"Out-of-bag predictions and evaluation","text":"Negation importance based --bag error, course may curious negation importance computed using different statistics. workflow exactly example , except two things: specify importance = 'negate' fit model. want use modified version C-stat, specifically 1 - C-stat, aorsf computes variable importance. Also, speed computations, going monitor --bag error .","code":"oobag_fun_tdep_cstat_inverse <- function(y_mat, w_vec, s_vec){  1 - oobag_fun_tdep_cstat(y_mat, w_vec, s_vec) } fit_tdep_cstat <- orsf(data = pbc_orsf,                        formula = Surv(time, status) ~ . - id,                        n_tree = 100,                        oobag_pred_horizon = 2000,                        oobag_fun = oobag_fun_tdep_cstat_inverse,                        importance = 'negate')  fit_tdep_cstat$importance #>        bili      copper         sex       stage         age     albumin  #> 0.142001860 0.044028870 0.035326500 0.029172120 0.022402290 0.020851380  #>     protime     ascites        chol         ast      hepato         trt  #> 0.020420260 0.015854010 0.013848700 0.008759570 0.008708080 0.007238590  #>       edema     spiders    platelet        trig    alk.phos  #> 0.006740447 0.004850580 0.004354200 0.004044760 0.000338090"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Out-of-bag predictions and evaluation","text":"evaluating --bag error: oobag_pred_horizon input orsf() determines prediction horizon --bag predictions. prediction horizon needs specified evaluate prediction accuracy cases, examples . sure check case using functions, , sure oobag_pred_horizon matches prediction horizon used custom function. functions expect predicted risk (.e., 1 - predicted survival), others expect predicted survival. cases, also able use function whatsoever compute --bag prediction error estimating negation permutation importance, assuming passes tests . Unfortunately, exception riskRegression::Score(), one favorites. experimented riskRegression::Score found work try run C++. sure case.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"partial-dependence-pd","dir":"Articles","previous_headings":"","what":"Partial dependence (PD)","title":"PD and ICE curves with ORSF","text":"Partial dependence (PD) shows expected prediction model function single predictor multiple predictors. expectation marginalized values predictors, giving something like multivariable adjusted estimate model’s prediction. Begin fitting ORSF ensemble. Set prediction horizon 5 years fit ensemble aorsf function pass ensemble assume want compute predictions 5 years.","code":"library(aorsf)  pred_horizon <- 365.25 * 5  set.seed(329730)  index_train <- sample(nrow(pbc_orsf), 150)   pbc_orsf_train <- pbc_orsf[index_train, ] pbc_orsf_test <- pbc_orsf[-index_train, ]  fit <- orsf(data = pbc_orsf_train,              formula = Surv(time, status) ~ . - id,             oobag_pred_horizon = pred_horizon)  fit #> ---------- Oblique random survival forest #>  #>      Linear combinations: Accelerated Cox regression #>           N observations: 150 #>                 N events: 52 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 10 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.83 #>            OOB stat type: Harrell's C-statistic #>      Variable importance: anova #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"three-ways-to-compute-pd","dir":"Articles","previous_headings":"","what":"Three ways to compute PD","title":"PD and ICE curves with ORSF","text":"can compute PD three ways aorsf: using -bag predictions training data using --bag predictions training data using predictions new set data -bag PD indicates relationships model learned training. helpful goal interpret model. --bag PD indicates relationships model learned training using --bag data simulates application model new data. want test model’s reliability fairness new data don’t access large testing set. new data PD shows model predicts outcomes observations seen. helpful want test model’s reliability fairness. Let’s re-fit ORSF available data proceeding next sections.","code":"pd_inb <- orsf_pd_inb(fit, pred_spec = list(bili = 1:5))  pd_inb #>    pred_horizon bili     mean      lwr      medn      upr #> 1:      1826.25    1 102.2195 10.56752  51.70595 387.4604 #> 2:      1826.25    2 118.4078 17.32437  65.74035 400.8656 #> 3:      1826.25    3 139.0911 27.40620  91.89857 408.6268 #> 4:      1826.25    4 164.2179 46.18212 122.28649 417.1405 #> 5:      1826.25    5 182.0078 63.40648 141.82025 418.7087 pd_oob <- orsf_pd_oob(fit, pred_spec = list(bili = 1:5))  pd_oob #>    pred_horizon bili     mean       lwr     medn      upr #> 1:      1826.25    1 37.76901  3.647149 20.75476 138.4846 #> 2:      1826.25    2 43.60922  6.744936 25.94581 143.4564 #> 3:      1826.25    3 51.10701 10.559067 33.92746 146.7145 #> 4:      1826.25    4 60.39102 17.167164 43.91971 148.7279 #> 5:      1826.25    5 66.86149 22.974170 52.92217 149.4068 pd_test <- orsf_pd_new(fit,                         new_data = pbc_orsf_test,                         pred_spec = list(bili = 1:5))  pd_test #>    pred_horizon bili     mean      lwr      medn      upr #> 1:      1826.25    1 121.9492 10.89852  88.98409 402.3823 #> 2:      1826.25    2 137.7431 19.82376 107.62643 411.1170 #> 3:      1826.25    3 159.0215 31.77017 133.55714 418.7824 #> 4:      1826.25    4 184.4336 52.11282 162.76413 427.0102 #> 5:      1826.25    5 202.2365 69.23467 179.79970 428.3857 set.seed(329730)  fit <- orsf(pbc_orsf,              Surv(time, status) ~ . -id,             oobag_pred_horizon = pred_horizon)"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"one-variable-one-horizon","dir":"Articles","previous_headings":"","what":"One variable, one horizon","title":"PD and ICE curves with ORSF","text":"Computing PD single variable straightforward: output shows expected predicted mortality risk men substantially higher women 5 years baseline.","code":"pd_sex <- orsf_pd_oob(fit, pred_spec = list(sex = c(\"m\", \"f\")))  pd_sex #>    pred_horizon sex     mean      lwr     medn      upr #> 1:      1826.25   m 63.53740 7.497887 42.23959 171.1578 #> 2:      1826.25   f 54.75067 2.468652 28.75373 172.9705"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"one-variable-moving-horizon","dir":"Articles","previous_headings":"","what":"One variable, moving horizon","title":"PD and ICE curves with ORSF","text":"effect predictor varies time? PD can show .  inspection, can see males higher risk females difference risk grows time. can also seen viewing ratio expected risk time:","code":"pd_sex_tv <- orsf_pd_oob(fit, pred_spec = list(sex = c(\"m\", \"f\")),                          pred_horizon = seq(365, 365*5))  ggplot(pd_sex_tv, aes(x = pred_horizon, y = mean, color = sex)) +   geom_line() +  labs(x = 'Time since baseline',       y = 'Expected risk') library(data.table)  ratio_tv <- pd_sex_tv[  , .(ratio = mean[sex == 'm'] / mean[sex == 'f']), by = pred_horizon ]  ggplot(ratio_tv, aes(x = pred_horizon, y = ratio)) +   geom_line(color = 'grey') +   geom_smooth(color = 'black', se = FALSE) +   labs(x = 'time since baseline',       y = 'ratio in expected risk for males versus females') #> `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"multiple-variables-marginally","dir":"Articles","previous_headings":"","what":"Multiple variables, marginally","title":"PD and ICE curves with ORSF","text":"want compute PD marginally multiple variables, just list variable values pred_spec specify expand_grid = FALSE. Now tedious wanted variables? bet. ’s made function . bonus, printed output sorted least important variables. ’s easy enough turn ‘summary’ object data.table downstream plotting tables.","code":"pd_two_vars <-    orsf_pd_oob(fit,              pred_spec = list(sex = c(\"m\", \"f\"), bili = 1:5),              expand_grid = FALSE)  pd_two_vars #>    pred_horizon variable value level     mean       lwr     medn      upr #> 1:      1826.25      sex    NA     m 63.53740  7.497887 42.23959 171.1578 #> 2:      1826.25      sex    NA     f 54.75067  2.468652 28.75373 172.9705 #> 3:      1826.25     bili     1  <NA> 43.68602  2.978101 23.34969 162.8759 #> 4:      1826.25     bili     2  <NA> 52.72685  7.498980 33.79082 166.1665 #> 5:      1826.25     bili     3  <NA> 62.01334 12.316319 44.92275 168.6863 #> 6:      1826.25     bili     4  <NA> 70.57266 16.257759 56.01187 171.3270 #> 7:      1826.25     bili     5  <NA> 76.79981 22.784187 64.11744 171.0076 pd_smry <- orsf_summarize_uni(fit)  pd_smry #>  #> -- bili (VI Rank: 1) ---------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>             0.80 42.76956 22.87303  9.760966  65.64725 #>              1.4 46.46358 26.71842 11.400230  70.74476 #>              3.5 66.97564 52.04698 29.390557 100.30862 #>  #> -- copper (VI Rank: 2) -------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %   75th % #>               43 48.30671 25.44210  9.800599 81.05387 #>               74 51.81202 30.16294 11.400460 87.20542 #>              129 61.48848 40.86822 19.854743 99.06423 #>  #> -- sex (VI Rank: 3) ----------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>                m 63.53740 42.23959 20.255777 103.39532 #>                f 54.75067 28.75373  9.892973  98.94158 #>  #> -- stage (VI Rank: 4) --------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>                1 47.25758 25.38280  8.762940  79.54398 #>                2 49.35287 26.57585  9.062014  84.80126 #>                3 53.81682 29.16159  9.625907  93.32760 #>                4 61.96506 38.46477 14.861775 102.33259 #>  #> -- albumin (VI Rank: 5) ------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>              3.3 58.69228 35.37468 12.246548 102.49537 #>              3.5 53.95786 29.29480 10.268949  96.05815 #>              3.8 50.82568 27.06886  9.576127  87.78778 #>  #> -- protime (VI Rank: 6) ------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>               10 51.62019 28.12880  9.952737  89.62418 #>               11 54.18521 31.05421 11.188875  97.39311 #>               11 58.17686 35.39740 13.008907 102.05172 #>  #> -- age (VI Rank: 7) ----------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>               42 49.99060 24.40002  9.446024  83.21520 #>               50 54.92105 31.97963 10.012422  94.67995 #>               57 60.70761 41.95011 13.569666 101.10360 #>  #> -- ast (VI Rank: 8) ----------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>               82 51.61525 26.90622  9.463562  89.41994 #>              117 54.72540 29.28642 10.308621  95.26257 #>              153 59.13439 32.73735 13.082732 104.08976 #>  #> -- ascites (VI Rank: 9) ------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>                0 54.73573 30.15086  9.976891  96.16124 #>                1 84.83590 71.70870 46.062706 119.06475 #>  #> -- chol (VI Rank: 10) --------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %   75th % #>              250 52.63911 28.02835  8.771679 89.05580 #>              310 54.11355 29.29366  9.933875 92.62154 #>              401 58.04422 35.81307 14.115239 94.47714 #>  #> -- hepato (VI Rank: 11) ------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %   75th % #>                0 52.66225 28.36684  9.769944 91.56514 #>                1 58.65340 34.34768 12.815355 99.13336 #>  #> -- edema (VI Rank: 12) -------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>                0 53.92404 29.59332  9.892973  98.09435 #>              0.5 64.80614 42.19899 19.479803 108.48979 #>                1 83.74960 66.79471 47.098091 116.25984 #>  #> -- spiders (VI Rank: 13) ------------------------------ #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %    75th % #>                0 53.70748 27.91868  9.769944  92.31117 #>                1 61.11270 39.49467 16.081293 102.03971 #>  #> -- trt (VI Rank: 14) ---------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %   75th % #>  d_penicill_main 56.39510 31.45237 11.356340 96.80732 #>          placebo 55.64182 28.99214  9.773986 98.76487 #>  #> -- trig (VI Rank: 15) --------------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median    25th %   75th % #>               85 53.76399 28.78363  9.646458 92.05122 #>              108 55.37901 30.51787  9.870543 94.64143 #>              151 58.04076 33.34603 11.136125 95.82748 #>  #> -- alk.phos (VI Rank: 16) ----------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median   25th %    75th % #>              922 55.83922 30.53669 10.42756  99.43128 #>             1278 55.98154 30.71802 10.55300  99.90380 #>             2068 56.70115 31.81157 11.18242 101.91749 #>  #> -- platelet (VI Rank: 17) ----------------------------- #>  #>                  |--------------- Risk ---------------| #>            Value     Mean   Median   25th %    75th % #>              200 56.76997 31.43144 10.63878 101.86206 #>              257 55.68783 30.48313 10.18891 100.30689 #>              318 54.83003 28.47392 10.53596  99.31576 #>  #>  Predicted risk at time t = 1826.25 for top 17 predictors head(as.data.table(pd_smry)) #>    variable importance Value     Mean   Median    25th %    75th % pred_horizon #> 1:     bili 0.12460516  0.80 42.76956 22.87303  9.760966  65.64725      1826.25 #> 2:     bili 0.12460516   1.4 46.46358 26.71842 11.400230  70.74476      1826.25 #> 3:     bili 0.12460516   3.5 66.97564 52.04698 29.390557 100.30862      1826.25 #> 4:   copper 0.05317731    43 48.30671 25.44210  9.800599  81.05387      1826.25 #> 5:   copper 0.05317731    74 51.81202 30.16294 11.400460  87.20542      1826.25 #> 6:   copper 0.05317731   129 61.48848 40.86822 19.854743  99.06423      1826.25 #>    level #> 1:  <NA> #> 2:  <NA> #> 3:  <NA> #> 4:  <NA> #> 5:  <NA> #> 6:  <NA>"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"multiple-variables-jointly","dir":"Articles","previous_headings":"","what":"Multiple variables, jointly","title":"PD and ICE curves with ORSF","text":"PD can show expected value model’s predictions function specific predictor, function multiple predictors. instance, can estimate predicted risk joint function bili, edema, trt:  inspection, model’s predictions indicate slightly lower risk placebo group, seem change much different values bili edema. clear increase predicted risk higher levels edema higher levels bili slope predicted risk function bili appears highest among patients edema 0.5. effect bili modified edema 0.5? quick sanity check coxph suggests .","code":"pred_spec = list(bili = seq(1, 5, length.out = 20),                  edema = levels(pbc_orsf_train$edema),                  trt = levels(pbc_orsf$trt))  pd_bili_edema <- orsf_pd_oob(fit, pred_spec)  library(ggplot2)  ggplot(pd_bili_edema, aes(x = bili, y = medn, col = trt, linetype = edema)) +   geom_line() +   labs(y = 'Expected predicted risk') library(survival)  pbc_orsf$edema_05 <- ifelse(pbc_orsf$edema == '0.5', 'yes', 'no')  fit_cph <- coxph(Surv(time,status) ~ edema_05 * bili,                   data = pbc_orsf)  anova(fit_cph) #> Analysis of Deviance Table #>  Cox model: response is Surv(time, status) #> Terms added sequentially (first to last) #>  #>                loglik   Chisq Df Pr(>|Chi|)     #> NULL          -550.19                           #> edema_05      -546.83  6.7248  1   0.009508 **  #> bili          -513.59 66.4689  1  3.555e-16 *** #> edema_05:bili -510.54  6.1112  1   0.013433 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"individual-conditional-expectations-ice","dir":"Articles","previous_headings":"","what":"Individual conditional expectations (ICE)","title":"PD and ICE curves with ORSF","text":"Unlike partial dependence, shows expected prediction function one multiple predictors, individual conditional expectations (ICE) show prediction individual observation function predictor. Just like PD, can compute ICE using -bag, --bag, testing data, principles apply. ’ll use --bag estimates .","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"visualizing-ice-curves","dir":"Articles","previous_headings":"","what":"Visualizing ICE curves","title":"PD and ICE curves with ORSF","text":"Inspecting ICE curves observation can help identify whether heterogeneity model’s predictions. .e., effect variable follow pattern data, groups variable impacts risk differently? going turn boundary checking orsf_ice_oob setting boundary_checks = FALSE, allow generate ICE curves go beyond 90th percentile bili. id_variable identifier current value variable(s) data. redundant one variable, helpful multiple variables. id_row identifier observation original data. used group observation’s predictions together plots. plots, helpful scale ICE data. subtract initial value predicted risk (.e., bili = 1) observation’s conditional expectation values. , Every curve start 0 plot shows change predicted risk function bili. Now can visualize curves.  inspection figure, individual slopes cluster around overall trend - Good! small number individual slopes appear flat. may helpful investigate .","code":"pred_spec <- list(bili = seq(1, 10, length.out = 25))  ice_oob <- orsf_ice_oob(fit, pred_spec, boundary_checks = FALSE)  ice_oob #>       id_variable id_row pred_horizon bili      pred #>    1:           1      1      1826.25    1 163.81290 #>    2:           1      2      1826.25    1  20.24450 #>    3:           1      3      1826.25    1 132.15795 #>    4:           1      4      1826.25    1  60.88751 #>    5:           1      5      1826.25    1  18.43827 #>   ---                                                #> 6896:          25    272      1826.25   10  46.01674 #> 6897:          25    273      1826.25   10  81.51583 #> 6898:          25    274      1826.25   10  86.66240 #> 6899:          25    275      1826.25   10  52.07688 #> 6900:          25    276      1826.25   10  92.31704 ice_oob[, pred_subtract := rep(pred[id_variable==1], times=25)] ice_oob[, pred := pred - pred_subtract] library(ggplot2)  ggplot(ice_oob, aes(x = bili,                      y = pred,                      group = id_row)) +   geom_line(alpha = 0.15) +   labs(y = 'Change in predicted risk') +  geom_smooth(se = FALSE, aes(group = 1)) #> `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"limitations-of-pd","dir":"Articles","previous_headings":"","what":"Limitations of PD","title":"PD and ICE curves with ORSF","text":"Partial dependence number known limitations assumptions users aware (see Hooker, 2021). particular, partial dependence less intuitive >2 predictors examined jointly, assumed feature(s) partial dependence computed correlated features (likely true many cases). Accumulated local effect plots can used (see ) case feature independence valid assumption.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"PD and ICE curves with ORSF","text":"Giles Hooker, Lucas Mentch, Siyu Zhou. Unrestricted Permutation forces Extrapolation: Variable Importance Requires least One Model, Free Variable Importance. arXiv e-prints 2021 Oct; arXiv-1905. URL: https://doi.org/10.48550/arXiv.1905.03151","code":""},{"path":"https://bcjaeger.github.io/aorsf/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Byron Jaeger. Author, maintainer. Nicholas Pajewski. Contributor. Sawyer Welden. Contributor. Christopher Jackson. Reviewer. Marvin Wright. Reviewer. Lukas Burk. Reviewer.","code":""},{"path":"https://bcjaeger.github.io/aorsf/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jaeger et al. (2022). aorsf: R package supervised learning using oblique random survival forest. Journal Open Source Software, 7(77), 4705. https://doi.org/10.21105/joss.04705. Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey , Pajewski NM. Accelerated interpretable oblique random survival forests. Journal Computational Graphical Statistics. 2023 Aug 3:1-6. Jaeger BC, Long DL, Long DM, Sims M, Szychowski JM, Min YI, Mcclure LA, Howard G, Simon N. Oblique Random Survival Forests. Annals Applied Statistics. 13(3): 1847-1883. URL https://doi.org/10.1214/19-AOAS1261 DOI: 10.1214/19-AOAS1261","code":"@Article{,   title = {aorsf: An R package for supervised learning using the oblique random survival forest},   author = {Byron C. Jaeger and Sawyer Welden and Kristin Lenoir and Nicholas M. Pajewski},   journal = {Journal of Open Source Software},   year = {2022},   volume = {7},   number = {77},   pages = {4705},   url = {https://doi.org/10.21105/joss.04705}, } @Article{,   title = {Accelerated and interpretable oblique random survival forests},   author = {Byron C. Jaeger and Sawyer Welden and Kristin Lenoir and Jaime L. Speiser and Matthew W. Segar and Ambarish Pandey and Nicholas M. Pajewski},   journal = {Journal of Computational and Graphical Statistics},   year = {2023},   url = {https://doi.org/10.1080/10618600.2023.2231048}, } @Article{,   title = {Oblique Random Survival Forests},   author = {Byron C. Jaeger and D. Leann Long and Dustin M. Long and Mario Sims and Jeff M. Szychowski and Yuan-I Min and Leslie A. Mcclure and George Howard and Noah Simon},   journal = {Annals of Applied Statistics},   year = {2019},   volume = {13},   number = {3},   pages = {1847--1883},   url = {https://doi.org/10.1214/19-AOAS1261}, }"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"aorsf-","dir":"","previous_headings":"","what":"Accelerated Oblique Random Survival Forests","title":"Accelerated Oblique Random Survival Forests","text":"Fit, interpret, make predictions oblique random survival forests (ORSFs).","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"why-aorsf","dir":"","previous_headings":"","what":"Why aorsf?","title":"Accelerated Oblique Random Survival Forests","text":"Hundreds times faster obliqueRSF.1 Accurate predictions censored outcomes.2 Negation importance, novel technique estimate variable importance ORSFs.2 Intuitive API formula based interface. Extensive input checks informative error messages.","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Accelerated Oblique Random Survival Forests","text":"can install aorsf CRAN using can install development version aorsf GitHub :","code":"install.packages(\"aorsf\") # install.packages(\"remotes\") remotes::install_github(\"ropensci/aorsf\")"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"what-is-an-oblique-decision-tree","dir":"","previous_headings":"","what":"What is an oblique decision tree?","title":"Accelerated Oblique Random Survival Forests","text":"Decision trees developed splitting set training data two new subsets, goal similarity within new subsets . splitting process repeated resulting subsets data stopping criterion met. new subsets data formed based single predictor, decision tree said axis-based splits data appear perpendicular axis predictor. linear combinations variables used instead single variable, tree oblique splits data neither parallel right angle axis. Figure: Decision trees classification axis-based splitting (left) oblique splitting (right). Cases orange squares; controls purple circles. trees partition predictor space defined variables X1 X2, oblique splits better job separating two classes.","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Accelerated Oblique Random Survival Forests","text":"orsf() function can fit several types ORSF ensembles. personal favorite accelerated ORSF great combination prediction accuracy computational efficiency (see JCGS paper).2","code":"library(aorsf)  set.seed(329730)  index_train <- sample(nrow(pbc_orsf), 150)   pbc_orsf_train <- pbc_orsf[index_train, ] pbc_orsf_test <- pbc_orsf[-index_train, ]  fit <- orsf(data = pbc_orsf_train,              formula = Surv(time, status) ~ . - id,             oobag_pred_horizon = 365.25 * 5)"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"inspect","dir":"","previous_headings":"Examples","what":"Inspect","title":"Accelerated Oblique Random Survival Forests","text":"Printing output orsf() give information descriptive statistics ensemble. See print.orsf_fit description line printed output. See orsf examples details controlling ORSF ensemble fits using prediction modeling workflows.","code":"fit #> ---------- Oblique random survival forest #>  #>      Linear combinations: Accelerated #>           N observations: 150 #>                 N events: 52 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 10 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.83 #>            OOB stat type: Harrell's C-statistic #>      Variable importance: anova #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"variable-importance","dir":"","previous_headings":"Examples","what":"Variable importance","title":"Accelerated Oblique Random Survival Forests","text":"importance individual variables can estimated three ways using aorsf: negation2: variable assessed separately multiplying variable’s coefficients -1 determining much model’s performance changes. worse model’s performance negating coefficients given variable, important variable. technique promising b/c require permutation emphasizes variables larger coefficients linear combinations, also relatively new hasn’t studied much permutation importance. See Jaeger, (2023) details technique. permutation: variable assessed separately randomly permuting variable’s values determining much model’s performance changes. worse model’s performance permuting values given variable, important variable. technique flexible, intuitive, frequently used. also several known limitations analysis variance (ANOVA)3: p-value computed coefficient linear combination variables decision tree. Importance individual predictor variable proportion times p-value coefficient < 0.01. technique efficient computationally, may effective permutation negation terms selecting signal noise variables. See Menze, 2011 details technique. can supply R function estimate --bag error using negation permutation importance (see oob vignette)","code":"orsf_vi_negate(fit) #>          bili           sex        copper         stage           age  #>  0.1162463868  0.0517905362  0.0375565841  0.0240450064  0.0239056901  #>           ast       protime        hepato         edema       ascites  #>  0.0191083400  0.0158014897  0.0139536512  0.0119264604  0.0100865906  #>       albumin          chol       spiders           trt          trig  #>  0.0085394443  0.0037903802  0.0030727468  0.0020617896  0.0018361632  #>      alk.phos      platelet  #>  0.0006586211 -0.0044967624 orsf_vi_permute(fit) #>          bili        copper           age         stage           sex  #>  0.0523994364  0.0187964038  0.0152246586  0.0115192591  0.0110127557  #>           ast        hepato         edema       ascites       albumin  #>  0.0100104477  0.0082889176  0.0079183046  0.0077834483  0.0070642325  #>       protime          trig          chol       spiders      alk.phos  #>  0.0066513097  0.0015656325  0.0014474560  0.0006015308  0.0001369292  #>           trt      platelet  #> -0.0013984860 -0.0022427356 orsf_vi_anova(fit) #>       bili    ascites      edema     copper      stage        sex        age  #> 0.48778004 0.44943820 0.41677872 0.31865585 0.26675095 0.26458616 0.25448430  #>        ast     hepato    albumin       chol    protime       trig    spiders  #> 0.21743929 0.19945726 0.18191604 0.15240328 0.15076561 0.13709677 0.11833550  #>   alk.phos   platelet        trt  #> 0.10113636 0.06302021 0.05019305"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"partial-dependence-pd","dir":"","previous_headings":"Examples","what":"Partial dependence (PD)","title":"Accelerated Oblique Random Survival Forests","text":"Partial dependence (PD) shows expected prediction model function single predictor multiple predictors. expectation marginalized values predictors, giving something like multivariable adjusted estimate model’s prediction. summary function, orsf_summarize_uni(), computes PD many variables ask , using sensible values. PD, see vignette","code":"orsf_summarize_uni(fit, n_variables = 2) #>  #> -- bili (VI Rank: 1) --------------------------- #>  #>        |---------------- Risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   0.70 0.1986719 0.1044026 0.04354701 0.2968290 #>    1.3 0.2132847 0.1210276 0.05245387 0.3208855 #>    3.2 0.2883814 0.1917119 0.11951296 0.4147258 #>  #> -- sex (VI Rank: 2) ---------------------------- #>  #>        |---------------- Risk ----------------| #>  Value      Mean    Median     25th %    75th % #>      m 0.3394141 0.2313787 0.13762339 0.5311308 #>      f 0.2390067 0.1112093 0.04782891 0.3773551 #>  #>  Predicted risk at time t = 1826.25 for top 2 predictors"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"individual-conditional-expectations-ice","dir":"","previous_headings":"Examples","what":"Individual conditional expectations (ICE)","title":"Accelerated Oblique Random Survival Forests","text":"Unlike partial dependence, shows expected prediction function one multiple predictors, individual conditional expectations (ICE) show prediction individual observation function predictor. ICE, see vignette","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"comparison-to-existing-software","dir":"","previous_headings":"","what":"Comparison to existing software","title":"Accelerated Oblique Random Survival Forests","text":"Comparisons aorsf existing software presented JCGS paper. paper: describes aorsf detail summary procedures used tree fitting algorithm runs general benchmark comparing aorsf obliqueRSF several learners reports prediction accuracy computational efficiency learners. runs simulation study comparing variable importance techniques ORSFs, axis based RSFs, boosted trees. reports probability variable importance technique rank relevant variable higher importance irrelevant variable. hands-comparison aorsf R packages provided orsf examples","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Accelerated Oblique Random Survival Forests","text":"Jaeger BC, Long DL, Long DM, Sims M, Szychowski JM, Min YI, Mcclure LA, Howard G, Simon N. Oblique random survival forests. Annals applied statistics 2019 Sep; 13(3):1847-83. DOI: 10.1214/19-AOAS1261 Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey , Pajewski NM. Accelerated interpretable oblique random survival forests. Journal Computational Graphical Statistics Published online 08 Aug 2023. DOI: 10.1080/10618600.2023.2231048 Menze BH, Kelm BM, Splitthoff DN, Koethe U, Hamprecht FA. oblique random forests. Joint European Conference Machine Learning Knowledge Discovery Databases 2011 Sep 4; pp. 453-469. DOI: 10.1007/978-3-642-23783-6_29","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"funding","dir":"","previous_headings":"","what":"Funding","title":"Accelerated Oblique Random Survival Forests","text":"developers aorsf receive financial support Center Biomedical Informatics, Wake Forest University School Medicine. also receive support National Center Advancing Translational Sciences National Institutes Health Award Number UL1TR001420. content solely responsibility authors necessarily represent official views National Institutes Health.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/aorsf-package.html","id":null,"dir":"Reference","previous_headings":"","what":"aorsf: Accelerated Oblique Random Survival Forests — aorsf-package","title":"aorsf: Accelerated Oblique Random Survival Forests — aorsf-package","text":"Fit, interpret, make predictions oblique random survival forests. Oblique decision trees notoriously slow compared axis based counterparts, 'aorsf' runs fast faster axis-based decision tree algorithms right-censored time--event outcomes. Methods accelerate interpret oblique random survival forest described Jaeger et al., (2023) doi:10.1080/10618600.2023.2231048 .","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/aorsf-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"aorsf: Accelerated Oblique Random Survival Forests — aorsf-package","text":"Maintainer: Byron Jaeger bjaeger@wakehealth.edu (ORCID) contributors: Nicholas Pajewski [contributor] Sawyer Welden swelden@wakehealth.edu [contributor] Christopher Jackson chris.jackson@mrc-bsu.cam.ac.uk [reviewer] Marvin Wright [reviewer] Lukas Burk [reviewer]","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/as.data.table.orsf_summary_uni.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to data.table — as.data.table.orsf_summary_uni","title":"Coerce to data.table — as.data.table.orsf_summary_uni","text":"Convert 'orsf_summary' object data.table object.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/as.data.table.orsf_summary_uni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to data.table — as.data.table.orsf_summary_uni","text":"","code":"# S3 method for orsf_summary_uni as.data.table(x, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/as.data.table.orsf_summary_uni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to data.table — as.data.table.orsf_summary_uni","text":"x object class 'orsf_summary_uni' ... used","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/as.data.table.orsf_summary_uni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to data.table — as.data.table.orsf_summary_uni","text":"data.table","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/as.data.table.orsf_summary_uni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to data.table — as.data.table.orsf_summary_uni","text":"","code":"library(data.table)  object <- orsf(pbc_orsf, Surv(time, status) ~ . - id)  smry <- orsf_summarize_uni(object, n_variables = 3)  as.data.table(smry) #>    variable importance value     mean     medn       lwr       upr pred_horizon #> 1:     bili 0.13264612  0.80 42.01978 22.73293  9.433101  62.67633         1788 #> 2:     bili 0.13264612   1.4 45.73376 25.84220 12.259889  68.56778         1788 #> 3:     bili 0.13264612   3.5 68.29821 53.38215 31.477659 101.26347         1788 #> 4:   copper 0.04622764    43 48.78155 26.20172  9.332737  84.70100         1788 #> 5:   copper 0.04622764    74 52.25780 29.50212 10.796756  91.05047         1788 #> 6:   copper 0.04622764   129 61.36591 39.26083 19.686092  99.87035         1788 #> 7:      sex 0.03186088     m 62.79089 42.29694 19.214162  99.35898         1788 #> 8:      sex 0.03186088     f 54.77684 28.95865  9.826841  98.31997         1788 #>    level #> 1:  <NA> #> 2:  <NA> #> 3:  <NA> #> 4:  <NA> #> 5:  <NA> #> 6:  <NA> #> 7:     m #> 8:     f"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Oblique Random Survival Forest (ORSF) — orsf","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Fit oblique random survival forest","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"","code":"orsf(   data,   formula,   control = orsf_control_fast(),   weights = NULL,   n_tree = 500,   n_split = 5,   n_retry = 3,   n_thread = 1,   mtry = NULL,   sample_with_replacement = TRUE,   sample_fraction = 0.632,   leaf_min_events = 1,   leaf_min_obs = 5,   split_rule = \"logrank\",   split_min_events = 5,   split_min_obs = 10,   split_min_stat = switch(split_rule, logrank = 3.841459, cstat = 0.5),   oobag_pred_type = \"surv\",   oobag_pred_horizon = NULL,   oobag_eval_every = n_tree,   oobag_fun = NULL,   importance = \"anova\",   group_factors = TRUE,   tree_seeds = NULL,   attach_data = TRUE,   no_fit = FALSE,   na_action = \"fail\",   verbose_progress = FALSE,   ... )  orsf_train(object)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"data data.frame, tibble, data.table contains relevant variables. formula (formula) response left hand side include time variable, followed status variable, may written inside call Surv (see examples). terms right names predictor variables. control (orsf_control) object returned one orsf_control functions: orsf_control_fast (default) uses single iteration Newton Raphson scoring identify linear combination predictors. orsf_control_cph uses Newton Raphson scoring convergence criteria met. orsf_control_net uses glmnet identify linear combinations predictors, similar Jaeger (2019). orsf_control_custom allows user apply function create linear combinations predictors. weights (numeric vector) Optional. given, input length equal nrow(data). Values weights treated like replication weights, .e., value 2 thing 2 observations data, containing copy corresponding person's data. Use weights cautiously, orsf count number observations events prior growing node tree, higher values weights lead deeper trees. n_tree (integer) number trees grow. Default n_tree = 500. n_split (integer) number cut-points assessed splitting node decision trees. Default n_split = 5. n_retry (integer) node can split, current linear combination inputs unable provide valid split, orsf try new linear combination based different set randomly selected predictors, n_retry times. Default n_retry = 3. Set n_retry = 0 prevent retries. n_thread (integer) number threads use growing trees, computing predictions, computing importance. Default one thread. use maximum number threads system provides concurrent execution, set n_thread = 0. mtry (integer) Number predictors randomly included candidates splitting node. default smallest integer greater square root number total predictors, .e., mtry = ceiling(sqrt(number predictors)) sample_with_replacement (logical) TRUE (default), observations sampled replacement -bag sample created decision tree. FALSE, observations sampled without replacement tree -bag sample containing sample_fraction% original sample. sample_fraction (double) proportion observations trees' -bag sample contain, relative number rows data. used sample_with_replacement FALSE. Default value 0.632. leaf_min_events (integer) minimum number events leaf node. Default leaf_min_events = 1 leaf_min_obs (integer) minimum number observations leaf node. Default leaf_min_obs = 5. split_rule (character) assess quality potential splitting rule node. Valid options 'logrank' : log-rank test statistic. 'cstat'   : Harrell's concordance statistic. split_min_events (integer) minimum number events required node consider splitting . Default split_min_events = 5 split_min_obs (integer) minimum number observations required node consider splitting . Default split_min_obs = 10. split_min_stat (double) minimum test statistic required split node. Default 3.841459 split_rule = 'logrank' 0.50 split_rule = 'cstat'. splits found statistic exceeding split_min_stat, given node either becomes leaf retry occurs (n_retry retries). oobag_pred_type (character) type --bag predictions compute fitting ensemble. Valid options 'none' : compute --bag predictions 'risk' : probability event occurring oobag_pred_horizon. 'surv' : 1 - risk. 'chf'  : cumulative hazard function oobag_pred_horizon. 'mort' : mortality, .e., number events expected observations training data identical given observation. oobag_pred_horizon (numeric) numeric value indicating time used --bag predictions. Default median observed times, .e., oobag_pred_horizon = median(time). oobag_eval_every (integer) --bag performance ensemble checked every oobag_eval_every trees. , oobag_eval_every = 10, --bag performance checked growing 10th tree, 20th tree, . Default oobag_eval_every = n_tree. oobag_fun (function) used evaluating --bag prediction accuracy every oobag_eval_every trees. oobag_fun = NULL (default), Harrell's C-statistic (1982) used evaluate accuracy. use oobag_fun note following: oobag_fun two inputs: y_mat s_vec y_mat two column matrix first column named 'time', second named 'status' s_vec numeric vector containing predicted survival probabilities. oobag_fun return numeric output length 1 details, see --bag vignette. importance (character) Indicate method variable importance: 'none': variable importance computed. 'anova': compute analysis variance (ANOVA) importance 'negate': compute negation importance 'permute': compute permutation importance details methods, see orsf_vi. group_factors (logical) relevant variable importance estimated. TRUE, importance factor variables reported overall aggregating importance individual levels factor. FALSE, importance individual factor levels returned. tree_seeds (integer vector) Optional. specified, random seeds set using values tree_seeds[]  growing tree . Two forests grown number trees seeds exact --bag samples, making --bag error estimates forests comparable. NULL (default), seeds set training process. attach_data (logical) TRUE, copy training data attached output. helpful plan using functions like orsf_pd_oob orsf_summarize_uni interpret forest using training data. Default TRUE. no_fit (logical) TRUE, model fitting steps defined saved, training initiated. object returned can directly submitted orsf_train() long attach_data TRUE. na_action (character) happen data contains missing values (.e., NA values). Valid options : 'fail' : error thrown data contains NA values 'omit' : rows data incomplete data dropped 'impute_meanmode' : missing values continuous categorical variables data imputed using mean mode, respectively. Note option selected attach_data TRUE, data attached output imputed version data. verbose_progress (logical) TRUE, progress messages printed console. FALSE (default), nothing printed. ... arguments passed methods (currently used). object untrained 'aorsf' object, created setting no_fit = TRUE orsf().","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"accelerated oblique RSF object (aorsf)","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"function based similar ORSF function obliqueRSF R package. primary difference function runs much faster. speed increase attributable better management memory (.e., unnecessary copies inputs) using Newton Raphson scoring algorithm identify linear combinations inputs rather performing penalized regression using routines glmnet.modified Newton Raphson scoring algorithm function applies adaptation C++ routine developed Terry M. Therneau fits Cox proportional hazards models (see survival::coxph() specifically survival::coxph.fit()).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"details-on-inputs","dir":"Reference","previous_headings":"","what":"Details on inputs","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"formula: response formula can survival object returned Surv function, can also just time status variables. .e., Surv(time, status) ~ . works just like time + status ~ . . symbol right hand side short-hand using variables data (omitting left hand side formula) predictors. order variables left hand side matters. .e., writing status + time ~ . make orsf assume status variable actually time variable. response variable can survival object stored data. example, y ~ . valid formula data$y inherits Surv class. Although can fit oblique random survival forest 1 predictor variable, formula least 2 predictors. reason recommendation linear combination predictors trivial one predictor. mtry: mtry parameter may temporarily reduced ensure least 2 events per predictor variable. occurs using orsf_control_cph coefficients Newton Raphson scoring algorithm may become unstable number covariates greater equal number events. reduction occur using orsf_control_net. oobag_fun: oobag_fun specified, used compute negation importance permutation importance, role ANOVA importance. n_thread: R function must called C++ (.e., user-supplied function compute --bag error identify linear combinations variables), n_thread automatically set 1 attempting run R functions multiple threads cause R session crash.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"what-is-an-oblique-decision-tree-","dir":"Reference","previous_headings":"","what":"What is an oblique decision tree?","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Decision trees developed splitting set training data two new subsets, goal similarity within new subsets . splitting process repeated resulting subsets data stopping criterion met. new subsets data formed based single predictor, decision tree said axis-based splits data appear perpendicular axis predictor. linear combinations variables used instead single variable, tree oblique splits data neither parallel right angle axis Figure : Decision trees classification axis-based splitting (left) oblique splitting (right). Cases orange squares; controls purple circles. trees partition predictor space defined variables X1 X2, oblique splits better job separating two classes.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"what-is-a-random-forest-","dir":"Reference","previous_headings":"","what":"What is a random forest?","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Random forests collections de-correlated decision trees. Predictions tree aggregated make ensemble prediction forest. details, see Breiman el, 2001.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"training-out-of-bag-error-and-testing","dir":"Reference","previous_headings":"","what":"Training, out-of-bag error, and testing","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"random forests, tree grown bootstrapped version training set. bootstrap samples selected replacement, bootstrapped training set contains two-thirds instances original training set. '--bag' data instances bootstrapped training set. tree random forest can make predictions --bag data, --bag predictions can aggregated make ensemble --bag prediction. Since --bag data used grow tree, accuracy ensemble --bag predictions approximate generalization error random forest. Generalization error refers error random forest's predictions applied predict outcomes data used train , .e., testing data.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"missing-data","dir":"Reference","previous_headings":"","what":"Missing data","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Data passed aorsf functions allowed missing values. user impute missing values using R package purpose, recipes mlr3pipelines.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"First load relevant packages   entry-point aorsf standard call orsf():   printing fit provides quick descriptive summaries:","code":"set.seed(329730) suppressPackageStartupMessages({  library(aorsf)  library(survival)  library(tidymodels)  library(tidyverse)  library(randomForestSRC)  library(ranger)  library(riskRegression)   library(obliqueRSF) }) fit <- orsf(pbc_orsf, Surv(time, status) ~ . - id) fit ## ---------- Oblique random survival forest ##  ##      Linear combinations: Accelerated ##           N observations: 276 ##                 N events: 111 ##                  N trees: 500 ##       N predictors total: 17 ##    N predictors per node: 5 ##  Average leaves per tree: 21 ## Min observations in leaf: 5 ##       Min events in leaf: 1 ##           OOB stat value: 0.84 ##            OOB stat type: Harrell's C-statistic ##      Variable importance: anova ##  ## -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"model-control","dir":"Reference","previous_headings":"","what":"Model control","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"examples make use orsf_control_ functions build compare models based --bag predictions. also standardize --bag samples using input argument tree_seeds","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"accelerated-linear-combinations","dir":"Reference","previous_headings":"","what":"Accelerated linear combinations","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"accelerated ORSF ensemble default nice balance computational speed prediction accuracy. runs single iteration Newton Raphson scoring Cox partial likelihood function find linear combinations predictors.","code":"fit_accel <- orsf(pbc_orsf,                    control = orsf_control_fast(),                   formula = Surv(time, status) ~ . - id,                   tree_seeds = 329)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"linear-combinations-with-cox-regression","dir":"Reference","previous_headings":"","what":"Linear combinations with Cox regression","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"orsf_control_cph runs Cox regression non-terminal node survival tree, using regression coefficients create linear combinations predictors:","code":"fit_cph <- orsf(pbc_orsf,                  control = orsf_control_cph(),                 formula = Surv(time, status) ~ . - id,                 tree_seeds = 329)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"linear-combinations-with-penalized-cox-regression","dir":"Reference","previous_headings":"","what":"Linear combinations with penalized cox regression","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"orsf_control_net runs penalized Cox regression non-terminal node survival tree, using regression coefficients create linear combinations predictors. can really helpful want feature selection within node, lot slower options.","code":"# select 3 predictors out of 5 to be used in # each linear combination of predictors. fit_net <- orsf(pbc_orsf,                  control = orsf_control_net(df_target = 3),                 formula = Surv(time, status) ~ . - id,                 tree_seeds = 329)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"linear-combinations-with-your-own-function","dir":"Reference","previous_headings":"","what":"Linear combinations with your own function","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Let’s make two customized functions identify linear combinations predictors. first uses random coefficients   second derives coefficients principal component analysis.   third uses orsf() inside orsf().   can plug functions orsf_control_custom(), pass result orsf():   fit seems work best example? Let’s find evaluating --bag survival predictions.   AUC values, highest lowest:     indices prediction accuracy:     inspection, net, accel, rlt high discrimination index prediction accuracy. rando pca less well, aren’t bad.","code":"f_rando <- function(x_node, y_node, w_node){  matrix(runif(ncol(x_node)), ncol=1)  } f_pca <- function(x_node, y_node, w_node) {    # estimate two principal components.  pca <- stats::prcomp(x_node, rank. = 2)  # use the second principal component to split the node  pca$rotation[, 1L, drop = FALSE]  } # This approach is known as reinforcement learning trees.   # some special care is taken to prevent your R session from crashing. # Specifically, random coefficients are used when n_obs <= 10 # or n_events <= 5.   f_aorsf <- function(x_node, y_node, w_node){   colnames(y_node) <- c('time', 'status')  colnames(x_node) <- paste(\"x\", seq(ncol(x_node)), sep = '')   data <- as.data.frame(cbind(y_node, x_node))   if(nrow(data) <= 10 || sum(y_node[,'status']) <= 5)    return(matrix(runif(ncol(x_node)), ncol = 1))   fit <- orsf(data, time + status ~ .,               weights = as.numeric(w_node),              n_tree = 25,              importance = 'permute')   out <- orsf_vi(fit)   # drop the least two important variables  n_vars <- length(out)  out[c(n_vars, n_vars-1)] <- 0   # ensure out has same variable order as input  out <- out[colnames(x_node)]   matrix(out, ncol = 1)  } fit_rando <- orsf(pbc_orsf,                   Surv(time, status) ~ . - id,                   control = orsf_control_custom(beta_fun = f_rando),                   tree_seeds = 329)  fit_pca <- orsf(pbc_orsf,                 Surv(time, status) ~ . - id,                 control = orsf_control_custom(beta_fun = f_pca),                 tree_seeds = 329)  fit_rlt <- orsf(pbc_orsf, time + status ~ . - id,                  control = orsf_control_custom(beta_fun = f_aorsf),                 tree_seeds = 329) risk_preds <- list(  accel = 1 - fit_accel$pred_oobag,  cph   = 1 - fit_cph$pred_oobag,  net   = 1 - fit_net$pred_oobag,  rando = 1 - fit_rando$pred_oobag,  pca   = 1 - fit_pca$pred_oobag,  rlt   = 1 - fit_rlt$pred_oobag )  sc <- Score(object = risk_preds,              formula = Surv(time, status) ~ 1,              data = pbc_orsf,              summary = 'IPA',             times = fit_accel$pred_horizon) sc$AUC$score[order(-AUC)] ##    model times       AUC         se     lower     upper ## 1:   net  1788 0.9134593 0.02079935 0.8726933 0.9542253 ## 2: accel  1788 0.9112315 0.02098077 0.8701099 0.9523530 ## 3:   rlt  1788 0.9076685 0.02078732 0.8669261 0.9484109 ## 4:   cph  1788 0.9063871 0.02165434 0.8639453 0.9488288 ## 5: rando  1788 0.9023489 0.02218936 0.8588586 0.9458393 ## 6:   pca  1788 0.8994220 0.02201713 0.8562692 0.9425748 sc$Brier$score[order(-IPA), .(model, times, IPA)] ##         model times       IPA ## 1:        net  1788 0.4916038 ## 2:      accel  1788 0.4879683 ## 3:        cph  1788 0.4751883 ## 4:        rlt  1788 0.4570179 ## 5:        pca  1788 0.4370592 ## 6:      rando  1788 0.4258344 ## 7: Null model  1788 0.0000000"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"tidymodels","dir":"Reference","previous_headings":"","what":"tidymodels","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"example uses tidymodels functions stops short using official tidymodels workflow. working getting aorsf pulled censored package update real workflows happens!","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"comparing-orsf-with-other-learners","dir":"Reference","previous_headings":"","what":"Comparing ORSF with other learners","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Start recipe pre-process data   Next create 10-fold cross validation object pre-process data:     Define functions ‘workflow’ randomForestSRC, ranger, aorsf.   Run ‘workflows’ fold:   Next unnest column get back tibble testing data predictions.     finish aggregating predictions computing performance testing data. Note computing one statistic predictions instead computing one statistic fold. approach fine smaller testing sets /small event counts.     inspection, aorsf obtained slightly higher discrimination (AUC) aorsf obtained higher index prediction accuracy (IPA)","code":"imputer <- recipe(pbc_orsf, formula = time + status ~ .) %>%   step_impute_mean(all_numeric_predictors()) %>%  step_impute_mode(all_nominal_predictors()) # 10-fold cross validation; make a container for the pre-processed data analyses <- vfold_cv(data = pbc_orsf, v = 10) %>%  mutate(recipe = map(splits, ~prep(imputer, training = training(.x))),         train = map(recipe, juice),         test = map2(splits, recipe, ~bake(.y, new_data = testing(.x))))  analyses ## #  10-fold cross-validation  ## # A tibble: 10 x 5 ##    splits           id     recipe   train               test               ##    <list>           <chr>  <list>   <list>              <list>             ##  1 <split [248/28]> Fold01 <recipe> <tibble [248 x 20]> <tibble [28 x 20]> ##  2 <split [248/28]> Fold02 <recipe> <tibble [248 x 20]> <tibble [28 x 20]> ##  3 <split [248/28]> Fold03 <recipe> <tibble [248 x 20]> <tibble [28 x 20]> ##  4 <split [248/28]> Fold04 <recipe> <tibble [248 x 20]> <tibble [28 x 20]> ##  5 <split [248/28]> Fold05 <recipe> <tibble [248 x 20]> <tibble [28 x 20]> ##  6 <split [248/28]> Fold06 <recipe> <tibble [248 x 20]> <tibble [28 x 20]> ##  7 <split [249/27]> Fold07 <recipe> <tibble [249 x 20]> <tibble [27 x 20]> ##  8 <split [249/27]> Fold08 <recipe> <tibble [249 x 20]> <tibble [27 x 20]> ##  9 <split [249/27]> Fold09 <recipe> <tibble [249 x 20]> <tibble [27 x 20]> ## 10 <split [249/27]> Fold10 <recipe> <tibble [249 x 20]> <tibble [27 x 20]> rfsrc_wf <- function(train, test, pred_horizon){    # rfsrc does not like tibbles, so cast input data into data.frames  train <- as.data.frame(train)  test <- as.data.frame(test)    rfsrc(formula = Surv(time, status) ~ ., data = train) %>%    predictRisk(newdata = test, times = pred_horizon) %>%    as.numeric()   }  ranger_wf <- function(train, test, pred_horizon){    ranger(Surv(time, status) ~ ., data = train) %>%    predictRisk(newdata = test, times = pred_horizon) %>%    as.numeric()   }  aorsf_wf <- function(train, test, pred_horizon){    train %>%    orsf(Surv(time, status) ~ .,) %>%    predict(new_data = test, pred_horizon = pred_horizon) %>%    as.numeric()   } # 5 year risk prediction ph <- 365.25 * 5  results <- analyses %>%   transmute(test,             pred_aorsf = map2(train, test, aorsf_wf, pred_horizon = ph),            pred_rfsrc = map2(train, test, rfsrc_wf, pred_horizon = ph),            pred_ranger = map2(train, test, ranger_wf, pred_horizon = ph)) results <- results %>%   unnest(everything())  glimpse(results) ## Rows: 276 ## Columns: 23 ## $ id          <int> 20, 47, 55, 57, 63, 65, 83, 121, 141, 181, 197, 201, 202, ~ ## $ trt         <fct> placebo, placebo, d_penicill_main, d_penicill_main, placeb~ ## $ age         <dbl> 59.95346, 47.42779, 65.76318, 53.57153, 46.62834, 40.20260~ ## $ sex         <fct> f, f, m, f, f, f, f, m, f, f, f, f, f, f, m, f, m, f, f, f~ ## $ ascites     <fct> 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0~ ## $ hepato      <fct> 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1~ ## $ spiders     <fct> 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1~ ## $ edema       <fct> 0, 0, 0, 0.5, 1, 0, 0.5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ~ ## $ bili        <dbl> 5.1, 0.5, 1.8, 2.3, 22.5, 1.2, 1.3, 1.3, 0.9, 1.4, 0.6, 0.~ ## $ chol        <int> 374, 316, 416, 260, 932, 256, 250, 151, 346, 248, 266, 235~ ## $ albumin     <dbl> 3.51, 3.65, 3.94, 3.18, 3.12, 3.60, 3.50, 3.08, 3.77, 3.58~ ## $ copper      <int> 140, 68, 121, 231, 95, 74, 48, 73, 59, 63, 25, 26, 15, 12,~ ## $ alk.phos    <dbl> 1919.0, 1716.0, 10165.0, 11320.2, 5396.0, 724.0, 1138.0, 1~ ## $ ast         <dbl> 122.45, 187.55, 79.98, 105.78, 244.90, 141.05, 71.30, 46.5~ ## $ trig        <int> 135, 71, 219, 94, 133, 108, 100, 49, 56, 106, 102, 67, 89,~ ## $ platelet    <int> 322, 356, 213, 216, 165, 430, 81, 213, 336, 79, 201, 228, ~ ## $ protime     <dbl> 13.0, 9.8, 11.0, 12.4, 11.6, 10.0, 12.9, 13.2, 10.6, 10.3,~ ## $ stage       <ord> 4, 3, 3, 3, 3, 1, 4, 4, 2, 4, 2, 4, 2, 1, 2, 3, 2, 4, 3, 4~ ## $ time        <int> 1356, 2576, 1360, 3282, 859, 3992, 4050, 191, 3050, 2556, ~ ## $ status      <dbl> 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0~ ## $ pred_aorsf  <dbl> 0.74325933, 0.07171843, 0.26549931, 0.65886824, 0.88328061~ ## $ pred_rfsrc  <dbl> 0.60298524, 0.05715514, 0.19512613, 0.57592127, 0.75772791~ ## $ pred_ranger <dbl> 0.61244412, 0.02793571, 0.17943870, 0.64002784, 0.74174298~ Score(  object = list(aorsf = results$pred_aorsf,                rfsrc = results$pred_rfsrc,                ranger = results$pred_ranger),  formula = Surv(time, status) ~ 1,   data = results,   summary = 'IPA',  times = ph ) ##  ## Metric AUC: ##  ## Results by model: ##  ##     model times  AUC lower upper ## 1:  aorsf  1826 90.2  85.8  94.6 ## 2:  rfsrc  1826 89.4  84.9  93.9 ## 3: ranger  1826 89.8  85.5  94.1 ##  ## Results of model comparisons: ##  ##    times  model reference delta.AUC lower upper   p ## 1:  1826  rfsrc     aorsf      -0.8  -2.3   0.6 0.3 ## 2:  1826 ranger     aorsf      -0.4  -1.8   1.0 0.6 ## 3:  1826 ranger     rfsrc       0.4  -0.7   1.6 0.4  ##  ## NOTE: Values are multiplied by 100 and given in %.  ## NOTE: The higher AUC the better.  ##  ## Metric Brier: ##  ## Results by model: ##  ##         model   times Brier lower upper  IPA ## 1: Null model 1826.25  20.5  18.1  22.9  0.0 ## 2:      aorsf 1826.25  11.0   8.7  13.3 46.2 ## 3:      rfsrc 1826.25  12.0   9.8  14.2 41.3 ## 4:     ranger 1826.25  11.8   9.7  14.0 42.3 ##  ## Results of model comparisons: ##  ##      times  model  reference delta.Brier lower upper            p ## 1: 1826.25  aorsf Null model        -9.5 -12.1  -6.8 1.504600e-12 ## 2: 1826.25  rfsrc Null model        -8.5 -10.8  -6.1 7.469601e-13 ## 3: 1826.25 ranger Null model        -8.7 -11.0  -6.3 1.022843e-12 ## 4: 1826.25  rfsrc      aorsf         1.0   0.3   1.7 5.805166e-03 ## 5: 1826.25 ranger      aorsf         0.8   0.1   1.5 2.164528e-02 ## 6: 1826.25 ranger      rfsrc        -0.2  -0.7   0.3 4.329685e-01  ##  ## NOTE: Values are multiplied by 100 and given in %.  ## NOTE: The lower Brier the better, the higher IPA the better."},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"mlr-pipelines","dir":"Reference","previous_headings":"","what":"mlr3 pipelines","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Warning: code may may run depending current version mlr3proba. First load additional mlr3 libraries.   Next ’ll define tasks learners engage .   Now can make benchmark designed compare three favorite learners:   Let’s look overall results:     inspection, aorsf higher expected value ‘surv.cindex’ (higher better) aorsf lower expected value ‘surv.graf’ (lower better)","code":"suppressPackageStartupMessages({  library(mlr3verse)  library(mlr3proba)  library(mlr3extralearners)  library(mlr3viz)  library(mlr3benchmark) }) # Mayo Clinic Primary Biliary Cholangitis Data task_pbc <-   TaskSurv$new(   id = 'pbc',     backend = select(pbc_orsf, -id) %>%     mutate(stage = as.numeric(stage)),     time = \"time\",    event = \"status\"  )  # Veteran's Administration Lung Cancer Trial data(veteran, package = \"randomForestSRC\")  task_veteran <-   TaskSurv$new(   id = 'veteran',     backend = veteran,     time = \"time\",    event = \"status\"  )  # NKI 70 gene signature data_nki <- OpenML::getOMLDataSet(data.id = 1228)  task_nki <-   TaskSurv$new(   id = 'nki',     backend = data_nki$data,     time = \"time\",    event = \"event\"  )  # Gene Expression-Based Survival Prediction in Lung Adenocarcinoma data_lung <- OpenML::getOMLDataSet(data.id = 1245)  task_lung <-   TaskSurv$new(   id = 'nki',     backend = data_lung$data %>%     mutate(OS_event = as.numeric(OS_event) -1),     time = \"OS_years\",    event = \"OS_event\"  )   # Chemotherapy for Stage B/C colon cancer # (there are two rows per person, one for death  #  and the other for recurrence, hence the two tasks)  task_colon_death <-  TaskSurv$new(   id = 'colon_death',     backend = survival::colon %>%    filter(etype == 2) %>%     drop_na() %>%     # drop id, redundant variables    select(-id, -study, -node4, -etype),    mutate(OS_event = as.numeric(OS_event) -1),     time = \"time\",    event = \"status\"  )  task_colon_recur <-  TaskSurv$new(   id = 'colon_death',     backend = survival::colon %>%    filter(etype == 1) %>%     drop_na() %>%     # drop id, redundant variables    select(-id, -study, -node4, -etype),    mutate(OS_event = as.numeric(OS_event) -1),     time = \"time\",    event = \"status\"  )  # putting them all together tasks <- list(task_pbc,               task_veteran,               task_nki,               task_lung,               task_colon_death,               task_colon_recur,               # add a few more pre-made ones               tsk(\"actg\"),               tsk('gbcs'),               tsk('grace'),               tsk(\"unemployment\"),               tsk(\"whas\")) # Learners with default parameters learners <- lrns(c(\"surv.ranger\", \"surv.rfsrc\", \"surv.aorsf\"))  # Brier (Graf) score, c-index and training time as measures measures <- msrs(c(\"surv.graf\", \"surv.cindex\", \"time_train\"))  # Benchmark with 5-fold CV design <- benchmark_grid(   tasks = tasks,   learners = learners,   resamplings = rsmps(\"cv\", folds = 5) )  benchmark_result <- benchmark(design)  bm_scores <- benchmark_result$score(measures, predict_sets = \"test\") bm_scores %>%  select(task_id, learner_id, surv.graf, surv.cindex, time_train) %>%  group_by(learner_id) %>%   filter(!is.infinite(surv.graf)) %>%   summarize(   across(    .cols = c(surv.graf, surv.cindex, time_train),    .fns = mean,     na.rm = TRUE   )  ) ## # A tibble: 3 x 4 ##   learner_id  surv.graf surv.cindex time_train ##   <chr>           <dbl>       <dbl>      <dbl> ## 1 surv.aorsf      0.152       0.733      1.41  ## 2 surv.ranger     0.166       0.712      1.95  ## 3 surv.rfsrc      0.155       0.723      0.745"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Harrell FE, Califf RM, Pryor DB, Lee KL, Rosati RA. Evaluating Yield Medical Tests. JAMA 1982; 247(18):2543-2546. DOI: 10.1001/jama.1982.03320430047030 Breiman L. Random forests. Machine learning 2001 Oct; 45(1):5-32. DOI: 10.1023/:1010933404324 Ishwaran H, Kogalur UB, Blackstone EH, Lauer MS. Random survival forests. Annals applied statistics 2008 Sep; 2(3):841-60. DOI: 10.1214/08-AOAS169 Jaeger BC, Long DL, Long DM, Sims M, Szychowski JM, Min YI, Mcclure LA, Howard G, Simon N. Oblique random survival forests. Annals applied statistics 2019 Sep; 13(3):1847-83. DOI: 10.1214/19-AOAS1261 Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey , Pajewski NM. Accelerated interpretable oblique random survival forests. Journal Computational Graphical Statistics Published online 08 Aug 2023. DOI: 10.1080/10618600.2023.2231048","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":null,"dir":"Reference","previous_headings":"","what":"Cox regression ORSF control — orsf_control_cph","title":"Cox regression ORSF control — orsf_control_cph","text":"Use coefficients proportional hazards model create linear combinations predictor variables fitting orsf model.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cox regression ORSF control — orsf_control_cph","text":"","code":"orsf_control_cph(method = \"efron\", eps = 1e-09, iter_max = 20, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cox regression ORSF control — orsf_control_cph","text":"method (character) character string specifying method tie handling. ties, methods equivalent. Valid options 'breslow' 'efron'. Efron approximation default accurate dealing tied event times similar computational efficiency compared Breslow method. eps (double) using Newton Raphson scoring identify linear combinations inputs, iteration continues algorithm relative change  log partial likelihood less eps, absolute change less sqrt(eps). Must positive. default value 1e-09 used consistency survival::coxph.control. iter_max (integer) iteration continues convergence (see eps ) number attempted iterations equal iter_max. ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cox regression ORSF control — orsf_control_cph","text":"object class 'orsf_control', used input control argument orsf.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cox regression ORSF control — orsf_control_cph","text":"code  survival package modified make routine. details Cox proportional hazards model, see coxph /Therneau Grambsch (2000).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cox regression ORSF control — orsf_control_cph","text":"Therneau T.M., Grambsch P.M. (2000) Cox Model. : Modeling Survival Data: Extending Cox Model. Statistics Biology Health. Springer, New York, NY. DOI: 10.1007/978-1-4757-3294-8_3","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cox regression ORSF control — orsf_control_cph","text":"","code":"orsf(data = pbc_orsf,      formula = Surv(time, status) ~ . - id,      control = orsf_control_cph()) #> ---------- Oblique random survival forest #>  #>      Linear combinations: Cox regression #>           N observations: 276 #>                 N events: 111 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 21 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.84 #>            OOB stat type: Harrell's C-statistic #>      Variable importance: anova #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom ORSF control — orsf_control_custom","title":"Custom ORSF control — orsf_control_custom","text":"Custom ORSF control","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom ORSF control — orsf_control_custom","text":"","code":"orsf_control_custom(beta_fun, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Custom ORSF control — orsf_control_custom","text":"beta_fun (function) function define coefficients used linear combinations predictor variables. beta_fun must accept three inputs named x_node, y_node w_node, expect following types dimensions: x_node (matrix; n rows, p columns) y_node (matrix; n rows, 2 columns) w_node (matrix; n rows, 1 column) addition, beta_fun must return matrix p rows 1 column. conditions met, orsf_control_custom() let know. ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Custom ORSF control — orsf_control_custom","text":"object class 'orsf_control', used input control argument orsf.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Custom ORSF control — orsf_control_custom","text":"Two customized functions identify linear combinations predictors shown . first uses random coefficients second derives coefficients principal component analysis.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"random-coefficients","dir":"Reference","previous_headings":"","what":"Random coefficients","title":"Custom ORSF control — orsf_control_custom","text":"f_rando() function get random coefficients:   can plug f_rando orsf_control_custom(), pass result orsf():","code":"f_rando <- function(x_node, y_node, w_node){  matrix(runif(ncol(x_node)), ncol=1)  } library(aorsf)  fit_rando <- orsf(pbc_orsf,                   Surv(time, status) ~ . - id,                   control = orsf_control_custom(beta_fun = f_rando),                   n_tree = 500)  fit_rando ## ---------- Oblique random survival forest ##  ##      Linear combinations: Custom user function ##           N observations: 276 ##                 N events: 111 ##                  N trees: 500 ##       N predictors total: 17 ##    N predictors per node: 5 ##  Average leaves per tree: 20 ## Min observations in leaf: 5 ##       Min events in leaf: 1 ##           OOB stat value: 0.83 ##            OOB stat type: Harrell's C-statistic ##      Variable importance: anova ##  ## -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"principal-components","dir":"Reference","previous_headings":"","what":"Principal components","title":"Custom ORSF control — orsf_control_custom","text":"Follow steps , starting custom function:   plug function orsf_control_custom() pass result orsf():","code":"f_pca <- function(x_node, y_node, w_node) {     # estimate two principal components.  pca <- stats::prcomp(x_node, rank. = 2)  # use the second principal component to split the node  pca$rotation[, 2L, drop = FALSE]   } fit_pca <- orsf(pbc_orsf,                 Surv(time, status) ~ . - id,                 control = orsf_control_custom(beta_fun = f_pca),                 n_tree = 500)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"evaluate","dir":"Reference","previous_headings":"","what":"Evaluate","title":"Custom ORSF control — orsf_control_custom","text":"well two customized ORSFs ? Let’s compute indices prediction accuracy based --bag predictions:       PCA ORSF quite well! (higher IPA better)","code":"library(riskRegression) ## riskRegression version 2023.09.08 library(survival)  risk_preds <- list(rando = 1 - fit_rando$pred_oobag,                     pca = 1 - fit_pca$pred_oobag)  sc <- Score(object = risk_preds,              formula = Surv(time, status) ~ 1,              data = pbc_orsf,              summary = 'IPA',             times = fit_pca$pred_horizon) sc$Brier ##  ## Results by model: ##  ##         model times  Brier  lower  upper    IPA ## 1: Null model  1788 20.479 18.090 22.868  0.000 ## 2:      rando  1788 11.748  9.702 13.793 42.636 ## 3:        pca  1788 12.884 10.906 14.862 37.088 ##  ## Results of model comparisons: ##  ##    times model  reference delta.Brier   lower  upper            p ## 1:  1788 rando Null model      -8.731 -10.932 -6.531 7.346799e-15 ## 2:  1788   pca Null model      -7.595  -9.243 -5.947 1.666843e-19 ## 3:  1788   pca      rando       1.136   0.265  2.008 1.061347e-02  ##  ## NOTE: Values are multiplied by 100 and given in %.  ## NOTE: The lower Brier the better, the higher IPA the better."},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Accelerated ORSF control — orsf_control_fast","title":"Accelerated ORSF control — orsf_control_fast","text":"Fast methods identify linear combinations predictors fitting orsf model.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Accelerated ORSF control — orsf_control_fast","text":"","code":"orsf_control_fast(method = \"efron\", do_scale = TRUE, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Accelerated ORSF control — orsf_control_fast","text":"method (character) character string specifying method tie handling. ties, methods equivalent. Valid options 'breslow' 'efron'. Efron approximation default accurate dealing tied event times similar computational efficiency compared Breslow method. do_scale (logical) TRUE, values predictors scaled prior instance Newton Raphson scoring, using summary values data current node decision tree. ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Accelerated ORSF control — orsf_control_fast","text":"object class 'orsf_control', used input control argument orsf.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_fast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Accelerated ORSF control — orsf_control_fast","text":"code  survival package modified make routine. Adjust do_scale risk. Setting do_scale = FALSE reduce computation time also make orsf model dependent scale data, default value TRUE.","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_fast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Accelerated ORSF control — orsf_control_fast","text":"","code":"orsf(data = pbc_orsf,      formula = Surv(time, status) ~ . - id,      control = orsf_control_fast()) #> ---------- Oblique random survival forest #>  #>      Linear combinations: Accelerated Cox regression #>           N observations: 276 #>                 N events: 111 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 21 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.84 #>            OOB stat type: Harrell's C-statistic #>      Variable importance: anova #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalized Cox regression ORSF control — orsf_control_net","title":"Penalized Cox regression ORSF control — orsf_control_net","text":"Use regularized Cox proportional hazard models identify linear combinations input variables fitting orsf model.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penalized Cox regression ORSF control — orsf_control_net","text":"","code":"orsf_control_net(alpha = 1/2, df_target = NULL, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penalized Cox regression ORSF control — orsf_control_net","text":"alpha (double) elastic net mixing parameter. value 1 gives lasso penalty, value 0 gives ridge penalty. multiple values alpha given, penalized model fit using alpha value prior splitting node. df_target (integer) Preferred number variables used linear combination. ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Penalized Cox regression ORSF control — orsf_control_net","text":"object class 'orsf_control', used input control argument orsf.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Penalized Cox regression ORSF control — orsf_control_net","text":"df_target less mtry, separate argument orsf indicates number variables chosen random prior finding linear combination variables.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Penalized Cox regression ORSF control — orsf_control_net","text":"Simon N, Friedman J, Hastie T, Tibshirani R. Regularization paths Cox's proportional hazards model via coordinate descent. Journal statistical software 2011 Mar; 39(5):1. DOI: 10.18637/jss.v039.i05","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Penalized Cox regression ORSF control — orsf_control_net","text":"","code":"# orsf_control_net() is considerably slower than orsf_control_cph(), # The example uses n_tree = 25 so that my examples run faster, # but you should use at least 500 trees in applied settings.  orsf(data = pbc_orsf,      formula = Surv(time, status) ~ . - id,      n_tree = 25,      control = orsf_control_net()) #> ---------- Oblique random survival forest #>  #>      Linear combinations: Penalized Cox regression #>           N observations: 276 #>                 N events: 111 #>                  N trees: 25 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 24 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.82 #>            OOB stat type: Harrell's C-statistic #>      Variable importance: anova #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_ice_oob.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF Individual Conditional Expectations — orsf_ice_oob","title":"ORSF Individual Conditional Expectations — orsf_ice_oob","text":"Compute individual conditional expectations ORSF model. Unlike partial dependence, shows expected prediction function one multiple predictors, individual conditional expectations (ICE) show prediction individual observation function predictor. can compute individual conditional expectations three ways using random forest: using -bag predictions training data using --bag predictions training data using predictions new set data See examples details","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_ice_oob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF Individual Conditional Expectations — orsf_ice_oob","text":"","code":"orsf_ice_oob(   object,   pred_spec,   pred_horizon = NULL,   pred_type = \"risk\",   expand_grid = TRUE,   boundary_checks = TRUE,   n_thread = 1,   ... )  orsf_ice_inb(   object,   pred_spec,   pred_horizon = NULL,   pred_type = \"risk\",   expand_grid = TRUE,   boundary_checks = TRUE,   n_thread = 1,   ... )  orsf_ice_new(   object,   pred_spec,   new_data,   pred_horizon = NULL,   pred_type = \"risk\",   na_action = \"fail\",   expand_grid = TRUE,   boundary_checks = TRUE,   n_thread = 1,   ... )"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_ice_oob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF Individual Conditional Expectations — orsf_ice_oob","text":"object (orsf_fit) trained oblique random survival forest (see orsf). pred_spec (named list data.frame). pred_spec named list, item list vector values used points partial dependence function. name item list indicate variable modified take corresponding values. pred_spec data.frame, columns indicate variable names, values indicate variable values, partial dependence computed using inputs row. pred_horizon (double) value vector indicating time(s) predictions calibrated . E.g., predicting risk incident heart failure within next 10 years, pred_horizon = 10. pred_horizon can NULL pred_type 'mort', since mortality predictions aggregated event times pred_type (character) type predictions compute. Valid options 'risk' : probability event pred_horizon. 'surv' : 1 - risk. 'chf': cumulative hazard function 'mort': mortality prediction expand_grid (logical) TRUE, partial dependence computed possible combinations inputs pred_spec. FALSE, partial dependence computed variable pred_spec, separately. boundary_checks (logical) TRUE, pred_spec checked make sure requested values 10th 90th percentile object's training data. FALSE, checks skipped. n_thread (integer) number threads use computing predictions. Default one thread. use maximum number threads system provides concurrent execution, set n_thread = 0. ... arguments passed methods (currently used). new_data data.frame, tibble, data.table compute predictions . na_action (character) happen new_data contains missing values (.e., NA values). Valid options : 'fail' : error thrown new_data contains NA values 'omit' : rows new_data incomplete data dropped","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_ice_oob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF Individual Conditional Expectations — orsf_ice_oob","text":"data.table containing individual conditional expectations specified variable(s) specified prediction horizon(s).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_ice_oob.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORSF Individual Conditional Expectations — orsf_ice_oob","text":"Begin fitting ORSF ensemble     Use ensemble compute ICE values using --bag predictions:     Much detailed examples given vignette","code":"library(aorsf)  set.seed(329)  fit <- orsf(data = pbc_orsf, formula = Surv(time, status) ~ . - id)  fit ## ---------- Oblique random survival forest ##  ##      Linear combinations: Accelerated Cox regression ##           N observations: 276 ##                 N events: 111 ##                  N trees: 500 ##       N predictors total: 17 ##    N predictors per node: 5 ##  Average leaves per tree: 21 ## Min observations in leaf: 5 ##       Min events in leaf: 1 ##           OOB stat value: 0.84 ##            OOB stat type: Harrell's C-statistic ##      Variable importance: anova ##  ## ----------------------------------------- pred_spec <- list(bili = seq(1, 10, length.out = 25))  ice_oob <- orsf_ice_oob(fit, pred_spec, boundary_checks = FALSE)  ice_oob ##       id_variable id_row pred_horizon bili      pred ##    1:           1      1         1788    1 167.86459 ##    2:           1      2         1788    1  21.77000 ##    3:           1      3         1788    1 118.36972 ##    4:           1      4         1788    1  63.11360 ##    5:           1      5         1788    1  20.65211 ##   ---                                                ## 6896:          25    272         1788   10  61.93365 ## 6897:          25    273         1788   10  78.19472 ## 6898:          25    274         1788   10  89.93071 ## 6899:          25    275         1788   10  56.40274 ## 6900:          25    276         1788   10  99.28738"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF partial dependence — orsf_pd_oob","title":"ORSF partial dependence — orsf_pd_oob","text":"Compute partial dependence ORSF model. Partial dependence (PD) shows expected prediction model function single predictor multiple predictors. expectation marginalized values predictors, giving something like multivariable adjusted estimate model's prediction. can compute partial dependence three ways using random forest: using -bag predictions training data using --bag predictions training data using predictions new set data See examples details","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF partial dependence — orsf_pd_oob","text":"","code":"orsf_pd_oob(   object,   pred_spec,   pred_horizon = NULL,   pred_type = \"risk\",   expand_grid = TRUE,   prob_values = c(0.025, 0.5, 0.975),   prob_labels = c(\"lwr\", \"medn\", \"upr\"),   boundary_checks = TRUE,   n_thread = 1,   ... )  orsf_pd_inb(   object,   pred_spec,   pred_horizon = NULL,   pred_type = \"risk\",   expand_grid = TRUE,   prob_values = c(0.025, 0.5, 0.975),   prob_labels = c(\"lwr\", \"medn\", \"upr\"),   boundary_checks = TRUE,   n_thread = 1,   ... )  orsf_pd_new(   object,   pred_spec,   new_data,   pred_horizon = NULL,   pred_type = \"risk\",   na_action = \"fail\",   expand_grid = TRUE,   prob_values = c(0.025, 0.5, 0.975),   prob_labels = c(\"lwr\", \"medn\", \"upr\"),   boundary_checks = TRUE,   n_thread = 1,   ... )"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF partial dependence — orsf_pd_oob","text":"object (orsf_fit) trained oblique random survival forest (see orsf). pred_spec (named list data.frame). pred_spec named list, item list vector values used points partial dependence function. name item list indicate variable modified take corresponding values. pred_spec data.frame, columns indicate variable names, values indicate variable values, partial dependence computed using inputs row. pred_horizon (double) value vector indicating time(s) predictions calibrated . E.g., predicting risk incident heart failure within next 10 years, pred_horizon = 10. pred_horizon can NULL pred_type 'mort', since mortality predictions aggregated event times pred_type (character) type predictions compute. Valid options 'risk' : probability event pred_horizon. 'surv' : 1 - risk. 'chf': cumulative hazard function 'mort': mortality prediction expand_grid (logical) TRUE, partial dependence computed possible combinations inputs pred_spec. FALSE, partial dependence computed variable pred_spec, separately. prob_values (numeric) vector values 0 1, indicating quantiles used summarize partial dependence values set inputs. prob_values length prob_labels. quantiles calculated based predictions object set values indicated pred_spec. prob_labels (character) vector labels length prob_values, label indicating corresponding value prob_values labelled summarized outputs. prob_labels length prob_values. boundary_checks (logical) TRUE, pred_spec checked make sure requested values 10th 90th percentile object's training data. FALSE, checks skipped. n_thread (integer) number threads use computing predictions. Default one thread. use maximum number threads system provides concurrent execution, set n_thread = 0. ... arguments passed methods (currently used). new_data data.frame, tibble, data.table compute predictions . na_action (character) happen new_data contains missing values (.e., NA values). Valid options : 'fail' : error thrown new_data contains NA values 'omit' : rows new_data incomplete data dropped","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF partial dependence — orsf_pd_oob","text":"data.table containing partial dependence values specified variable(s) specified prediction horizon(s).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ORSF partial dependence — orsf_pd_oob","text":"Partial dependence number known limitations assumptions users aware (see Hooker, 2021). particular, partial dependence less intuitive >2 predictors examined jointly, assumed feature(s) partial dependence computed correlated features (likely true many cases). Accumulated local effect plots can used (see ) case feature independence valid assumption.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORSF partial dependence — orsf_pd_oob","text":"Begin fitting ORSF ensemble:","code":"library(aorsf)  set.seed(329730)  index_train <- sample(nrow(pbc_orsf), 150)   pbc_orsf_train <- pbc_orsf[index_train, ] pbc_orsf_test <- pbc_orsf[-index_train, ]  fit <- orsf(data = pbc_orsf_train,              formula = Surv(time, status) ~ . - id,             oobag_pred_horizon = 365.25 * 5)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":"three-ways-to-compute-pd-and-ice","dir":"Reference","previous_headings":"","what":"Three ways to compute PD and ICE","title":"ORSF partial dependence — orsf_pd_oob","text":"can compute partial dependence ICE three ways aorsf: using -bag predictions training data     using --bag predictions training data     using predictions new set data     -bag partial dependence indicates relationships model learned training. helpful goal interpret model. --bag partial dependence indicates relationships model learned training using --bag data simulates application model new data. want test model’s reliability fairness new data don’t access large testing set. new data partial dependence shows model predicts outcomes observations seen. helpful want test model’s reliability fairness.","code":"pd_train <- orsf_pd_inb(fit, pred_spec = list(bili = 1:5))  pd_train ##    pred_horizon bili     mean      lwr      medn      upr ## 1:      1826.25    1 101.9466 10.53944  51.65470 387.5041 ## 2:      1826.25    2 118.2382 16.90238  65.95072 400.6156 ## 3:      1826.25    3 138.9013 27.34446  91.45440 408.3768 ## 4:      1826.25    4 163.9056 46.18300 121.82058 417.1405 ## 5:      1826.25    5 181.6854 62.99029 140.65257 418.7087 pd_train <- orsf_pd_oob(fit, pred_spec = list(bili = 1:5))  pd_train ##    pred_horizon bili     mean       lwr     medn      upr ## 1:      1826.25    1 37.66151  3.607834 20.75476 137.8659 ## 2:      1826.25    2 43.56664  6.655814 25.94357 143.4564 ## 3:      1826.25    3 51.04030 10.102343 33.73989 146.7145 ## 4:      1826.25    4 60.28418 17.159042 43.95543 148.7279 ## 5:      1826.25    5 66.74464 22.974170 53.00352 149.4068 pd_test <- orsf_pd_new(fit,                         new_data = pbc_orsf_test,                         pred_spec = list(bili = 1:5))  pd_test ##    pred_horizon bili     mean      lwr     medn      upr ## 1:      1826.25    1 121.9552 10.86471  88.9915 402.0936 ## 2:      1826.25    2 137.8436 19.81224 107.7018 411.1170 ## 3:      1826.25    3 159.1454 31.76190 134.2937 418.7824 ## 4:      1826.25    4 184.4209 52.09751 162.6736 427.0102 ## 5:      1826.25    5 202.1922 69.21315 179.9189 428.3857"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_oob.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ORSF partial dependence — orsf_pd_oob","text":"Giles Hooker, Lucas Mentch, Siyu Zhou. Unrestricted Permutation forces Extrapolation: Variable Importance Requires least One Model, Free Variable Importance. arXiv e-prints 2021 Oct; arXiv-1905. URL: https://doi.org/10.48550/arXiv.1905.03151","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale input data — orsf_scale_cph","title":"Scale input data — orsf_scale_cph","text":"functions exported users may access internal routines used scale inputs orsf_control_cph used.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale input data — orsf_scale_cph","text":"","code":"orsf_scale_cph(x_mat, w_vec = NULL)  orsf_unscale_cph(x_mat)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale input data — orsf_scale_cph","text":"x_mat (numeric matrix) matrix values scaled unscaled. Note orsf_unscale_cph accept x_mat inputs attribute containing transform values, added automatically orsf_scale_cph. w_vec (numeric vector) optional vector weights. weights supplied (default), observations equally weighted. supplied, w_vec must length equal nrow(x_mat).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale input data — orsf_scale_cph","text":"scaled unscaled x_mat.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scale input data — orsf_scale_cph","text":"data transformed first subtracting mean multiplying scale. inverse transform can completed using orsf_unscale_cph dividing column corresponding scale adding mean. values means scales stored attribute output returned orsf_scale_cph (see examples)","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale input data — orsf_scale_cph","text":"","code":"x_mat <- as.matrix(pbc_orsf[, c('bili', 'age', 'protime')])  head(x_mat) #>   bili      age protime #> 1 14.5 58.76523    12.2 #> 2  1.1 56.44627    10.6 #> 3  1.4 70.07255    12.0 #> 4  1.8 54.74059    10.3 #> 5  3.4 38.10541    10.9 #> 7  1.0 55.53457     9.7  x_scaled <- orsf_scale_cph(x_mat)  head(x_scaled) #>             bili        age    protime #> [1,]  3.77308887  1.0412574  1.9694656 #> [2,] -0.75476469  0.7719344 -0.1822316 #> [3,] -0.65339483  2.3544852  1.7005035 #> [4,] -0.51823502  0.5738373 -0.5856748 #> [5,]  0.02240421 -1.3581657  0.2212116 #> [6,] -0.78855464  0.6660494 -1.3925613  attributes(x_scaled) # note the transforms attribute #> $dim #> [1] 276   3 #>  #> $dimnames #> $dimnames[[1]] #> NULL #>  #> $dimnames[[2]] #> [1] \"bili\"    \"age\"     \"protime\" #>  #>  #> $transforms #>           mean     scale #> [1,]  3.333696 0.3378995 #> [2,] 49.799661 0.1161396 #> [3,] 10.735507 1.3448108 #>   x_unscaled <- orsf_unscale_cph(x_scaled)  head(x_unscaled) #>      bili      age protime #> [1,] 14.5 58.76523    12.2 #> [2,]  1.1 56.44627    10.6 #> [3,]  1.4 70.07255    12.0 #> [4,]  1.8 54.74059    10.3 #> [5,]  3.4 38.10541    10.9 #> [6,]  1.0 55.53457     9.7  # numeric difference in x_mat and x_unscaled should be practically 0 max(abs(x_mat - x_unscaled)) #> [1] 8.881784e-16"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF summary; univariate — orsf_summarize_uni","title":"ORSF summary; univariate — orsf_summarize_uni","text":"Summarize univariate information ORSF object","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF summary; univariate — orsf_summarize_uni","text":"","code":"orsf_summarize_uni(   object,   n_variables = NULL,   pred_horizon = NULL,   pred_type = \"risk\",   importance = \"negate\",   ... )"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF summary; univariate — orsf_summarize_uni","text":"object (orsf_fit) trained oblique random survival forest (see orsf). n_variables (integer) many variables summarized? Setting input lower number reduce computation time. pred_horizon (double) value vector indicating time(s) predictions calibrated . E.g., predicting risk incident heart failure within next 10 years, pred_horizon = 10. pred_horizon can NULL pred_type 'mort', since mortality predictions aggregated event times pred_type (character) type predictions compute. Valid options 'risk' : probability event pred_horizon. 'surv' : 1 - risk. 'chf': cumulative hazard function 'mort': mortality prediction importance (character) Indicate method variable importance: 'none': variable importance computed. 'anova': compute analysis variance (ANOVA) importance 'negate': compute negation importance 'permute': compute permutation importance details methods, see orsf_vi. ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF summary; univariate — orsf_summarize_uni","text":"object class 'orsf_summary', includes data importance individual predictors. expected values predictions specific values predictors.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ORSF summary; univariate — orsf_summarize_uni","text":"pred_horizon left unspecified, median value time--event variable object's training data used. recommended always specify prediction horizon, median time may especially meaningful horizon compute predicted risk values . object already variable importance values, can safely bypass computation variable importance function setting importance = 'none'.","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORSF summary; univariate — orsf_summarize_uni","text":"","code":"object <- orsf(pbc_orsf, Surv(time, status) ~ . - id)  # since anova importance was used to make object, we can # safely say importance = 'none' and skip computation of # variable importance while running orsf_summarize_uni  orsf_summarize_uni(object, n_variables = 3, importance = 'none') #>  #> -- ascites (VI Rank: 1) --------------------- #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median   25th %    75th % #>      0 54.86871 30.25661 10.26982  96.40677 #>      1 84.34251 69.74953 45.72363 117.02118 #>  #> -- bili (VI Rank: 2) ------------------------ #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median    25th %   75th % #>   0.80 42.90022 23.27885  9.486851 65.81336 #>    1.4 46.66482 25.76556 12.595670 71.12989 #>    3.5 68.14285 51.72705 32.699670 98.03215 #>  #> -- edema (VI Rank: 3) ----------------------- #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median   25th %    75th % #>      0 54.07074 29.70578 10.18645  96.46844 #>    0.5 64.68420 43.51384 19.37882 107.06181 #>      1 86.13762 70.87138 52.28369 119.36485 #>  #>  Predicted risk at time t = 1788 for top 3 predictors   # however, if we want to summarize object according to variables # ranked by negation importance, we can compute negation importance # within orsf_summarize_uni() as follows:  orsf_summarize_uni(object, n_variables = 3, importance = 'negate') #>  #> -- bili (VI Rank: 1) ------------------------ #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median    25th %   75th % #>   0.80 42.90022 23.27885  9.486851 65.81336 #>    1.4 46.66482 25.76556 12.595670 71.12989 #>    3.5 68.14285 51.72705 32.699670 98.03215 #>  #> -- copper (VI Rank: 2) ---------------------- #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median   25th %   75th % #>     43 48.12626 26.30627 10.03022 82.70388 #>     74 51.72934 29.13116 11.51811 87.14670 #>    129 61.18186 40.94014 20.14981 98.73438 #>  #> -- sex (VI Rank: 3) ------------------------- #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median   25th %    75th % #>      m 64.37635 43.08159 21.56076 103.59910 #>      f 54.80322 29.38825 10.18645  98.06029 #>  #>  Predicted risk at time t = 1788 for top 3 predictors"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate training time — orsf_time_to_train","title":"Estimate training time — orsf_time_to_train","text":"Estimate training time","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate training time — orsf_time_to_train","text":"","code":"orsf_time_to_train(object, n_tree_subset = 50)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate training time — orsf_time_to_train","text":"object untrained aorsf object n_tree_subset (integer)  many trees fit order estimate time needed train object. default value 50, usually gives good enough approximation.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate training time — orsf_time_to_train","text":"difftime object.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate training time — orsf_time_to_train","text":"","code":"# specify but do not train the model by setting no_fit = TRUE. object <- orsf(pbc_orsf, Surv(time, status) ~ . - id,                n_tree = 500, no_fit = TRUE)  # grow 50 trees to approximate the time it will take to grow 500 trees time_estimated <- orsf_time_to_train(object, n_tree_subset = 50)  print(time_estimated) #> Time difference of 0.2592089 secs  # let's see how close the approximation was time_true_start <- Sys.time() fit <- orsf_train(object) time_true_stop <- Sys.time()  time_true <- time_true_stop - time_true_start  print(time_true) #> Time difference of 0.2336831 secs  # error abs(time_true - time_estimated) #> Time difference of 0.02552581 secs"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF variable importance — orsf_vi","title":"ORSF variable importance — orsf_vi","text":"Estimate importance individual variables using oblique random survival forests.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF variable importance — orsf_vi","text":"","code":"orsf_vi(   object,   group_factors = TRUE,   importance = NULL,   oobag_fun = NULL,   n_thread = 1,   verbose_progress = FALSE,   ... )  orsf_vi_negate(   object,   group_factors = TRUE,   oobag_fun = NULL,   n_thread = 1,   verbose_progress = FALSE,   ... )  orsf_vi_permute(   object,   group_factors = TRUE,   oobag_fun = NULL,   n_thread = 1,   verbose_progress = FALSE,   ... )  orsf_vi_anova(object, group_factors = TRUE, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF variable importance — orsf_vi","text":"object (orsf_fit) trained oblique random survival forest (see orsf). group_factors (logical) TRUE, importance factor variables reported overall aggregating importance individual levels factor. FALSE, importance individual factor levels returned. importance (character) Indicate method variable importance: 'anova': compute analysis variance (ANOVA) importance 'negate': compute negation importance 'permute': compute permutation importance oobag_fun (function) used evaluating --bag prediction accuracy negating coefficients (importance = 'negate') permuting values predictor (importance = 'permute') oobag_fun = NULL (default), Harrell's C-statistic (1982) used evaluate accuracy. use oobag_fun note following: oobag_fun two inputs: y_mat s_vec y_mat two column matrix first column named 'time', second named 'status' s_vec numeric vector containing predicted survival probabilities. oobag_fun return numeric output length 1 oobag_fun used created object initial value --bag prediction accuracy consistent values computed variable importance estimated. details, see --bag vignette. n_thread (integer) number threads use computing predictions. Default one thread. use maximum number threads system provides concurrent execution, set n_thread = 0. verbose_progress (logical) TRUE, progress messages printed console. FALSE (default), nothing printed. ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF variable importance — orsf_vi","text":"orsf_vi functions return named numeric vector. Names vector predictor variables used object Values vector estimated importance given predictor. returned vector sorted highest lowest value, higher values indicating higher importance.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ORSF variable importance — orsf_vi","text":"orsf_fit object fitted importance = 'anova', 'negate', 'permute', output vector importance values based requested type importance. However, may still want call orsf_vi() output want group factor levels one overall importance value. orsf_vi() general purpose function extract compute variable importance estimates 'orsf_fit' object (see orsf). orsf_vi_negate(), orsf_vi_permute(), orsf_vi_anova() wrappers orsf_vi(). way functions work depends whether object given already variable importance estimates (see examples).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"variable-importance-methods","dir":"Reference","previous_headings":"","what":"Variable importance methods","title":"ORSF variable importance — orsf_vi","text":"negation importance: variable assessed separately multiplying variable's coefficients -1 determining much model's performance changes. worse model's performance negating coefficients given variable, important variable. technique promising b/c require permutation emphasizes variables larger coefficients linear combinations, also relatively new studied much permutation importance. See Jaeger, (2023) details technique. permutation importance: variable assessed separately randomly permuting variable's values determining much model's performance changes. worse model's performance permuting values given variable, important variable. technique flexible, intuitive, frequently used. also several known limitations analysis variance (ANOVA) importance: p-value computed coefficient linear combination variables decision tree. Importance individual predictor variable proportion times p-value coefficient < 0.01. technique efficient computationally, may effective permutation negation terms selecting signal noise variables. See Menze, 2011 details technique.","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"anova-importance","dir":"Reference","previous_headings":"","what":"ANOVA importance","title":"ORSF variable importance — orsf_vi","text":"default variable importance technique, ANOVA, calculated fit ORSF ensemble.     ANOVA default fast, may decisive permutation negation techniques variable selection.","code":"fit <- orsf(pbc_orsf, Surv(time, status) ~ . - id)  fit ## ---------- Oblique random survival forest ##  ##      Linear combinations: Accelerated Cox regression ##           N observations: 276 ##                 N events: 111 ##                  N trees: 500 ##       N predictors total: 17 ##    N predictors per node: 5 ##  Average leaves per tree: 21 ## Min observations in leaf: 5 ##       Min events in leaf: 1 ##           OOB stat value: 0.84 ##            OOB stat type: Harrell's C-statistic ##      Variable importance: anova ##  ## -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"raw-vi-values","dir":"Reference","previous_headings":"","what":"Raw VI values","title":"ORSF variable importance — orsf_vi","text":"‘raw’ variable importance values can accessed fit object     ‘raw’ values factors aggregated single value. Currently one value k-1 levels k level factor. example, can see edema_1 edema_0.5 importance values edema factor variable levels 0, 0.5, 1.","code":"attr(fit, 'importance_values') ##     edema_1   ascites_1        bili      copper     albumin         age  ##  0.53189300  0.49950642  0.39598881  0.30443254  0.26028060  0.24758399  ##     protime       stage        chol   edema_0.5   spiders_1         ast  ##  0.22874192  0.20974576  0.20353982  0.18401760  0.18090452  0.17457962  ##    hepato_1       sex_f        trig    alk.phos    platelet trt_placebo  ##  0.16402406  0.14803440  0.13009809  0.11627907  0.07853659  0.06939410"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"collapse-vi-across-factor-levels","dir":"Reference","previous_headings":"","what":"Collapse VI across factor levels","title":"ORSF variable importance — orsf_vi","text":"get aggregated values across levels factor, access importance element orsf fit:     use orsf_vi() group_factors set TRUE (default)     Note can make default returned importance values ungrouped setting group_factors FALSE orsf_vi functions orsf function.","code":"fit$importance ##    ascites       bili      edema     copper    albumin        age    protime  ## 0.49950642 0.39598881 0.32482431 0.30443254 0.26028060 0.24758399 0.22874192  ##      stage       chol    spiders        ast     hepato        sex       trig  ## 0.20974576 0.20353982 0.18090452 0.17457962 0.16402406 0.14803440 0.13009809  ##   alk.phos   platelet        trt  ## 0.11627907 0.07853659 0.06939410 orsf_vi(fit) ##    ascites       bili      edema     copper    albumin        age    protime  ## 0.49950642 0.39598881 0.32482431 0.30443254 0.26028060 0.24758399 0.22874192  ##      stage       chol    spiders        ast     hepato        sex       trig  ## 0.20974576 0.20353982 0.18090452 0.17457962 0.16402406 0.14803440 0.13009809  ##   alk.phos   platelet        trt  ## 0.11627907 0.07853659 0.06939410"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"add-vi-to-an-orsf","dir":"Reference","previous_headings":"","what":"Add VI to an ORSF","title":"ORSF variable importance — orsf_vi","text":"can fit ORSF without VI, add VI later","code":"fit_no_vi <- orsf(pbc_orsf,                   Surv(time, status) ~ . - id,                   importance = 'none')  # Note: you can't call orsf_vi_anova() on fit_no_vi because anova # VI can only be computed while the forest is being grown.  orsf_vi_negate(fit_no_vi) ##        bili      copper         sex     protime       stage     albumin  ## 0.118368091 0.048934519 0.037084634 0.027045537 0.023883035 0.021168322  ##         age     ascites        chol         ast      hepato       edema  ## 0.020510253 0.014990139 0.014700024 0.011445420 0.007705758 0.007216976  ##     spiders        trig    alk.phos         trt    platelet  ## 0.006373687 0.003230074 0.002825097 0.002487956 0.001558061 orsf_vi_permute(fit_no_vi) ##          bili        copper       protime       albumin       ascites  ##  0.0546262009  0.0248983335  0.0154588025  0.0135496100  0.0134187625  ##           age         stage          chol         edema           ast  ##  0.0119125415  0.0114086074  0.0074840971  0.0052955192  0.0051264428  ##        hepato       spiders           sex          trig      alk.phos  ##  0.0050509057  0.0046277553  0.0039395847  0.0024127938  0.0009590829  ##      platelet           trt  ##  0.0004366080 -0.0018115005"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"orsf-and-vi-all-at-once","dir":"Reference","previous_headings":"","what":"ORSF and VI all at once","title":"ORSF variable importance — orsf_vi","text":"fit ORSF compute vi time     can still get negation VI fit, needs computed","code":"fit_permute_vi <- orsf(pbc_orsf,                         Surv(time, status) ~ . - id,                         importance = 'permute')  # get the vi instantly (i.e., it doesn't need to be computed again) orsf_vi_permute(fit_permute_vi) ##          bili        copper           age       ascites       albumin  ##  5.354589e-02  2.608966e-02  1.286604e-02  1.250721e-02  1.206669e-02  ##       protime         stage           ast          chol         edema  ##  1.083811e-02  1.056282e-02  8.224237e-03  6.016773e-03  5.831833e-03  ##       spiders        hepato           sex          trig      alk.phos  ##  4.736005e-03  3.446193e-03  3.440979e-03  2.277363e-03  2.224448e-03  ##      platelet           trt  ##  1.424653e-03 -1.351124e-05 orsf_vi_negate(fit_permute_vi) ##        bili      copper         sex       stage     protime     albumin  ## 0.124731632 0.052319855 0.038669229 0.027453339 0.022757244 0.022220823  ##         age         ast     ascites        chol     spiders       edema  ## 0.020417138 0.013403277 0.013193815 0.011895708 0.008962837 0.007361044  ##      hepato         trt        trig    alk.phos    platelet  ## 0.006428047 0.004371012 0.004240743 0.003232336 0.002575995"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ORSF variable importance — orsf_vi","text":"Harrell FE, Califf RM, Pryor DB, Lee KL, Rosati RA. Evaluating Yield Medical Tests. JAMA 1982; 247(18):2543-2546. DOI: 10.1001/jama.1982.03320430047030 Breiman L. Random forests. Machine learning 2001 Oct; 45(1):5-32. DOI: 10.1023/:1010933404324 Menze BH, Kelm BM, Splitthoff DN, Koethe U, Hamprecht FA. oblique random forests. Joint European Conference Machine Learning Knowledge Discovery Databases 2011 Sep 4; pp. 453-469. DOI: 10.1007/978-3-642-23783-6_29 Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey , Pajewski NM. Accelerated interpretable oblique random survival forests. Journal Computational Graphical Statistics Published online 08 Aug 2023. DOI: 10.1080/10618600.2023.2231048","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vs.html","id":null,"dir":"Reference","previous_headings":"","what":"Variable selection — orsf_vs","title":"Variable selection — orsf_vs","text":"Variable selection","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variable selection — orsf_vs","text":"","code":"orsf_vs(object, n_predictor_min = 3, verbose_progress = FALSE)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variable selection — orsf_vs","text":"object (orsf_fit) trained oblique random survival forest (see orsf). n_predictor_min (integer) minimum number predictors allowed verbose_progress (logical) implemented yet. progress printed console?","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variable selection — orsf_vs","text":"data.table four columns: n_predictors: number predictors used stat_value: --bag statistic predictors_included: names predictors included predictor_dropped: predictor selected dropped","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Variable selection — orsf_vs","text":"tree_seeds specified object successive run orsf evaluated --bag samples initial run.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variable selection — orsf_vs","text":"","code":"object <- orsf(formula = time + status ~ .,                data = pbc_orsf,                n_tree = 25,                importance = 'anova',                tree_seeds = 1:25)  orsf_vs(object) #>     n_predictors stat_value                       predictors_included #>  1:            3  0.7911870                        ascites,edema,bili #>  2:            4  0.8144174                 ascites,edema,bili,copper #>  3:            5  0.8244700             age,ascites,edema,bili,copper #>  4:            6  0.8238450      age,ascites,hepato,edema,bili,copper #>  5:            7  0.8130111  age,ascites,hepato,edema,bili,copper,... #>  6:            8  0.8252513 age,ascites,hepato,spiders,edema,bili,... #>  7:            9  0.8394187 age,ascites,hepato,spiders,edema,bili,... #>  8:           10  0.8418147 age,ascites,hepato,spiders,edema,bili,... #>  9:           11  0.8268139 age,ascites,hepato,spiders,edema,bili,... #> 10:           12  0.8338976  age,sex,ascites,hepato,spiders,edema,... #> 11:           13  0.8418147  age,sex,ascites,hepato,spiders,edema,... #> 12:           14  0.8394708  age,sex,ascites,hepato,spiders,edema,... #> 13:           15  0.8423876  age,sex,ascites,hepato,spiders,edema,... #> 14:           16  0.8237408  age,sex,ascites,hepato,spiders,edema,... #> 15:           17  0.8122298     id,age,sex,ascites,hepato,spiders,... #> 16:           18  0.8251992         id,trt,age,sex,ascites,hepato,... #>     predictor_dropped #>  1:              bili #>  2:            copper #>  3:               age #>  4:            hepato #>  5:           protime #>  6:           spiders #>  7:              chol #>  8:           albumin #>  9:               ast #> 10:               sex #> 11:              trig #> 12:             stage #> 13:          alk.phos #> 14:          platelet #> 15:                id #> 16:               trt"},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"data light modification survival::pbc data. modifications :","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"","code":"pbc_orsf"},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"data frame 276 rows 20 variables: id case number time number days registration earlier death, transplantion, study analysis July, 1986 status status endpoint, 0 censored transplant, 1 dead trt randomized treatment group: D-penicillmain placebo age years sex m/f ascites presence ascites hepato presence hepatomegaly enlarged liver spiders blood vessel malformations skin edema 0 edema, 0.5 untreated successfully treated, 1 edema despite diuretic therapy bili serum bilirubin (mg/dl) chol serum cholesterol (mg/dl) albumin serum albumin (g/dl) copper urine copper (ug/day) alk.phos alkaline phosphotase (U/liter) ast aspartate aminotransferase, called SGOT (U/ml) trig triglycerides (mg/dl) platelet platelet count protime standardized blood clotting time stage histologic stage disease (needs biopsy)","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"T Therneau P Grambsch (2000), Modeling Survival Data: Extending Cox Model, Springer-Verlag, New York. ISBN: 0-387-98784-3.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"removed rows missing data converted status 0 censor transplant, 1 dead converted stage ordered factor. converted trt, ascites, hepato, spiders, edema factors.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.orsf_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute predictions using ORSF — predict.orsf_fit","title":"Compute predictions using ORSF — predict.orsf_fit","text":"Predicted risk, survival, hazard, mortality ORSF model.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.orsf_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute predictions using ORSF — predict.orsf_fit","text":"","code":"# S3 method for orsf_fit predict(   object,   new_data,   pred_horizon = NULL,   pred_type = \"risk\",   na_action = \"fail\",   boundary_checks = TRUE,   n_thread = 1,   verbose_progress = FALSE,   pred_aggregate = TRUE,   ... )"},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.orsf_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute predictions using ORSF — predict.orsf_fit","text":"object (orsf_fit) trained oblique random survival forest (see orsf). new_data data.frame, tibble, data.table compute predictions . pred_horizon (double) value vector indicating time(s) predictions calibrated . E.g., predicting risk incident heart failure within next 10 years, pred_horizon = 10. pred_horizon can NULL pred_type 'mort', since mortality predictions aggregated event times pred_type (character) type predictions compute. Valid options 'risk' : probability event pred_horizon. 'surv' : 1 - risk. 'chf': cumulative hazard function 'mort': mortality prediction na_action (character) happen new_data contains missing values (.e., NA values). Valid options : 'fail' : error thrown new_data contains NA values 'pass' : output NA rows new_data 1 NA value predictors used object 'omit' : rows new_data incomplete data dropped 'impute_meanmode' : missing values continuous categorical variables new_data imputed using mean mode, respectively. clarify, mean mode used impute missing values training data object, new_data. boundary_checks (logical) TRUE, pred_horizon checked make sure requested values less maximum observed time object's training data. FALSE, checks skipped. n_thread (integer) number threads use computing predictions. Default one thread. use maximum number threads system provides concurrent execution, set n_thread = 0. verbose_progress (logical) TRUE, progress messages printed console. FALSE (default), nothing printed. pred_aggregate (logical) TRUE (default), predictions aggregated trees taking mean. FALSE, returned output contain one row per observation one column tree. length pred_horizon two pred_aggregate FALSE, result list matrices, 'th item list corresponding 'th value pred_horizon. ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.orsf_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute predictions using ORSF — predict.orsf_fit","text":"matrix predictions. Column j matrix corresponds value j pred_horizon. Row matrix corresponds row new_data.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.orsf_fit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute predictions using ORSF — predict.orsf_fit","text":"new_data must columns equivalent types data used train object. Also, factors new_data must levels data used train object. pred_horizon values exceed maximum follow-time object's training data, truly want , set boundary_checks = FALSE can use pred_horizon large want. Note predictions beyond maximum follow-time object's training data equal predictions maximum follow-time, aorsf estimate survival beyond maximum observed time. unspecified, pred_horizon may automatically specified value used oobag_pred_horizon object created (see orsf).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.orsf_fit.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute predictions using ORSF — predict.orsf_fit","text":"Begin fitting ORSF ensemble:   Predict risk, survival, cumulative hazard one several times:             Predict mortality, defined number events forest’s population observations characteristics like current observation. type prediction require specify prediction horizon","code":"library(aorsf)  set.seed(329730)  index_train <- sample(nrow(pbc_orsf), 150)   pbc_orsf_train <- pbc_orsf[index_train, ] pbc_orsf_test <- pbc_orsf[-index_train, ]  fit <- orsf(data = pbc_orsf_train,              formula = Surv(time, status) ~ . - id,             oobag_pred_horizon = 365.25 * 5) # predicted risk, the default predict(fit,          new_data = pbc_orsf_test[1:5, ],          pred_type = 'risk',          pred_horizon = c(500, 1000, 1500)) ##             [,1]       [,2]       [,3] ## [1,] 0.458321864 0.72956562 0.89157462 ## [2,] 0.032194868 0.08028381 0.15592011 ## [3,] 0.115945485 0.24099853 0.38094684 ## [4,] 0.008378033 0.02964250 0.06977315 ## [5,] 0.009798295 0.01793586 0.04454374 # predicted survival, i.e., 1 - risk predict(fit,          new_data = pbc_orsf_test[1:5, ],          pred_type = 'surv',         pred_horizon = c(500, 1000, 1500)) ##           [,1]      [,2]      [,3] ## [1,] 0.5416781 0.2704344 0.1084254 ## [2,] 0.9678051 0.9197162 0.8440799 ## [3,] 0.8840545 0.7590015 0.6190532 ## [4,] 0.9916220 0.9703575 0.9302269 ## [5,] 0.9902017 0.9820641 0.9554563 # predicted cumulative hazard function # (expected number of events for person i at time j) predict(fit,          new_data = pbc_orsf_test[1:5, ],          pred_type = 'chf',         pred_horizon = c(500, 1000, 1500)) ##            [,1]       [,2]       [,3] ## [1,] 0.63432745 1.26771489 1.74183802 ## [2,] 0.03415809 0.09124550 0.20017014 ## [3,] 0.14715014 0.34375274 0.62976148 ## [4,] 0.00857621 0.03195771 0.08744159 ## [5,] 0.01043219 0.01888677 0.05177019 predict(fit,          new_data = pbc_orsf_test[1:5, ],          pred_type = 'mort') ##           [,1] ## [1,] 78.575909 ## [2,] 20.872849 ## [3,] 37.341745 ## [4,] 13.616617 ## [5,]  8.798328"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect your ORSF model — print.orsf_fit","title":"Inspect your ORSF model — print.orsf_fit","text":"Printing ORSF model tells : Linear combinations: identified? N observations: Number rows training data N events: Number events training data N trees: Number trees forest N predictors total: Total number columns predictor matrix N predictors per node: Number variables used linear combinations Average leaves per tree: proxy depth trees Min observations leaf: See leaf_min_obs orsf Min events leaf: See leaf_min_events orsf OOB stat value: --bag error fitting trees OOB stat type: --bag error computed? Variable importance: variable importance computed?","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect your ORSF model — print.orsf_fit","text":"","code":"# S3 method for orsf_fit print(x, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect your ORSF model — print.orsf_fit","text":"x (orsf_fit) oblique random survival forest (ORSF; see orsf). ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect your ORSF model — print.orsf_fit","text":"x, invisibly.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect your ORSF model — print.orsf_fit","text":"","code":"object <- orsf(pbc_orsf, Surv(time, status) ~ . - id, n_tree = 5)  print(object) #> ---------- Oblique random survival forest #>  #>      Linear combinations: Accelerated Cox regression #>           N observations: 276 #>                 N events: 111 #>                  N trees: 5 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 21 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.77 #>            OOB stat type: Harrell's C-statistic #>      Variable importance: anova #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_summary_uni.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ORSF summary — print.orsf_summary_uni","title":"Print ORSF summary — print.orsf_summary_uni","text":"Print ORSF summary","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_summary_uni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ORSF summary — print.orsf_summary_uni","text":"","code":"# S3 method for orsf_summary_uni print(x, n_variables = NULL, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_summary_uni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ORSF summary — print.orsf_summary_uni","text":"x object class 'orsf_summary' n_variables number variables print ... arguments passed methods (currently used).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_summary_uni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ORSF summary — print.orsf_summary_uni","text":"invisibly, x","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.orsf_summary_uni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print ORSF summary — print.orsf_summary_uni","text":"","code":"object <- orsf(pbc_orsf, Surv(time, status) ~ . - id)  smry <- orsf_summarize_uni(object, n_variables = 3)  print(smry) #>  #> -- bili (VI Rank: 1) ------------------------ #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median    25th %    75th % #>   0.80 42.44400 22.40244  9.105295  66.25552 #>    1.4 46.52748 26.18841 12.659333  71.54002 #>    3.5 66.11311 49.03572 27.876011 101.10226 #>  #> -- copper (VI Rank: 2) ---------------------- #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median    25th %   75th % #>     43 47.41837 25.02467  8.657594 81.12858 #>     74 51.09855 30.19052 10.391971 87.97837 #>    129 60.78653 41.41145 18.505680 99.38507 #>  #> -- sex (VI Rank: 3) ------------------------- #>  #>        |--------------- Risk ---------------| #>  Value     Mean   Median    25th %   75th % #>      m 63.28763 43.42690 20.776516 102.0118 #>      f 54.23358 28.64476  9.815049  94.3412 #>  #>  Predicted risk at time t = 1788 for top 3 predictors"},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-012-unreleased","dir":"Changelog","previous_headings":"","what":"aorsf 0.1.2 (unreleased)","title":"aorsf 0.1.2 (unreleased)","text":"Added orsf_control functions classification, regression, survival (https://github.com/ropensci/aorsf/pull/25). optimization implemented matrix multiplication prediction (https://github.com/ropensci/aorsf/pull/20)","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-011","dir":"Changelog","previous_headings":"","what":"aorsf 0.1.1","title":"aorsf 0.1.1","text":"fixed uninitialized value pd_type","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-010","dir":"Changelog","previous_headings":"","what":"aorsf 0.1.0","title":"aorsf 0.1.0","text":"CRAN release: 2023-10-13 Re-worked internal C++ routines following design ranger. Re-worked progress printed console verbose_progress TRUE, following design ranger. Messages now indicate action taken, % complete, approximate time finishing action. Improved variable importance, following design ranger. Importance now computed tree--tree instead aggregate. Additionally, mortality type prediction used importance survival trees, since mortality depend pred_horizon. Allowed multi-threading performed orsf(), predict.orsf_fit(), functions orsf_vi() orsf_pd() family. Allowed sampling without replacement sampling specific fraction observations orsf() Included Harrell’s C-statistic option assessing goodness splits growing trees. Fixed issue uninformative error message occur pred_horizon > max(time) orsf_summarize_uni. Thanks @JyHao1 @DustinMLong finding !","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-007","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.7","title":"aorsf 0.0.7","text":"CRAN release: 2023-01-12 Additional changes internal testing avoid problems ATLAS","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-006","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.6","title":"aorsf 0.0.6","text":"CRAN release: 2023-01-06 Minor fix internal tests failing run ATLAS","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-005","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.5","title":"aorsf 0.0.5","text":"CRAN release: 2022-12-14 orsf() longer throws errors warnings try give single predictor. note added documentation details ?orsf explains using single predictor orsf() somewhat useless. done resolve https://github.com/mlr-org/mlr3extralearners/issues/259. predict.orsf_fit now accepts pred_horizon = 0 returns sensible values. Thanks @mattwarkentin feature request. added function perform variable selection, orsf_vs(). Made variable importance consistent respect group_factors. Originally, output orsf ungrouped VI values orsf_vi grouped values. update, orsf defaults grouped values. ungrouped values can still recovered. Fixed issue orsf_pd functions output data returned original scale.","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-004","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.4","title":"aorsf 0.0.4","text":"CRAN release: 2022-11-07 orsf formulas now accepts Surv objects (see https://github.com/ropensci/aorsf/issues/11) Added verbose_progress input orsf, prints messages console indicating progress. Allowance missing values orsf. Mean mode imputation performed observations missing data. values can also used impute new data missing values. Centering scaling predictors now done prior growing forest.","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-003","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.3","title":"aorsf 0.0.3","text":"CRAN release: 2022-10-09 Included rOpenSci reviewers Christopher Jackson, Marvin N Wright, Lukas Burk DESCRIPTION reviewers. Thank ! Added clarification docs pros/cons different variable importance techniques Added regression tests aorsf versus obliqueRSF (similar) Additional support tests functions long right hand sides Updated --bag vignette appropriate custom functions. Allow status values input data general, .e., just 0 1. Allow missing values predict functions, including partial dependence.","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-002","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.2","title":"aorsf 0.0.2","text":"CRAN release: 2022-09-05 Modified unit tests compatibility extra checks run CRAN.","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-001","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.1","title":"aorsf 0.0.1","text":"CRAN release: 2022-08-23 Added orsf_control_custom(), allows users submit custom functions identifying linear combinations inputs growing oblique decision trees. Added weights input orsf, allowing users fit orsf specific data training set. Added chf mort options predict.orsf_fit(). Mortality predictions fully implemented yet - supported partial dependence --bag error estimates. features added future update.","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-0009000","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.0.9000","title":"aorsf 0.0.0.9000","text":"Core features implemented: fit, interpret, predict using oblique random survival forests. Vignettes + Readme covering usage core features. Website hosted GitHub pages, managed pkgdown.","code":""}]
